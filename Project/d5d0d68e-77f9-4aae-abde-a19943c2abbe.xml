<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//	NAME:					HE_RT100Status&#xD;
//	CREATOR:				Helgevold - Jan Magne Dybvik&#xD;
// REQUIREMENTS: NX CPU&#xD;
//&#xD;
// DESCRTIPTION: 	Read RT100 status&#xD;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//  VERSION LOG:&#xD;
//	 VERSION			DATE				SIGN						DESCRIPTION&#xD;
//	 1.0					2025-04-01		Jan Magne Dybvik	Initial release&#xD;
//&#xD;
//&#xD;
//================================================================================================================================&#xD;
&#xD;
&#xD;
CASE Wrk_State OF&#xD;
	// Initialize&#xD;
	0:&#xD;
		Clear(Wrk_SendData);&#xD;
		Clear(Wrk_RecvData);&#xD;
		Clear(Wrk_RecvString);&#xD;
		Clear(Wrk_SendString);&#xD;
		Wrk_RecvSize := 0;&#xD;
		Wrk_SendSize := 0;&#xD;
		&#xD;
		Clear(Out_LinkState);&#xD;
		Clear(Out_WirelessGen);&#xD;
		Clear(Out_Operator);&#xD;
		Out_Signal := 0;&#xD;
		&#xD;
		Wrk_State := 10;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
		&#xD;
	// Idle&#xD;
	10:&#xD;
		IF Wrk_TimeInState &gt; Cfg_CheckInterval THEN&#xD;
			Wrk_State := 20;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
		&#xD;
	&#xD;
	//SktTCPConnect&#xD;
    20:&#xD;
        Wrk_TCP_Connect := TRUE;&#xD;
		Wrk_State := 21;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
		&#xD;
	21:&#xD;
		&#xD;
        IF Wrk_SktTCPConnect.Done THEN&#xD;
            Wrk_State := 30;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ConnectionError := FALSE;&#xD;
		ELSIF NOT Wrk_SktTCPConnect.Busy THEN&#xD;
			Wrk_State := 10;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1021_0001;&#xD;
        ELSIF Wrk_SktTCPConnect.Error THEN&#xD;
            Wrk_State := 10;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1021_0002;&#xD;
			Wrk_ConnectionError := TRUE;&#xD;
		ELSIF Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
			Wrk_State := 10; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1021_0003;&#xD;
			Wrk_ConnectionError := TRUE;&#xD;
    END_IF;&#xD;
&#xD;
&#xD;
	 //SktTLSConnect&#xD;
    30:&#xD;
    Wrk_EstTLSSession := TRUE;&#xD;
	 Wrk_State := 31;&#xD;
	Wrk_TimeInState := T#0s;&#xD;
	&#xD;
	&#xD;
	31:&#xD;
    IF Wrk_SktTLSConnect.Done THEN&#xD;
        Wrk_State := 40;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
	ELSIF NOT Wrk_SktTLSConnect.Busy THEN&#xD;
		Wrk_State := 90;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
		Wrk_ErrorCode := 16#1031_0001;&#xD;
    ELSIF  Wrk_SktTLSConnect.Error THEN&#xD;
        Wrk_State := 90; &#xD;
		Wrk_TimeInState := T#0s;&#xD;
		Wrk_ErrorCode := 16#1031_0002;&#xD;
	ELSIF Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
		Wrk_State := 90; &#xD;
		Wrk_TimeInState := T#0s;&#xD;
		Wrk_ErrorCode := 16#1031_0003;&#xD;
    END_IF;&#xD;
&#xD;
&#xD;
	//SktTLSClearBuf&#xD;
    40:&#xD;
        Wrk_SktClearBuffer := TRUE;&#xD;
		&#xD;
        IF Wrk_SktTLSClearBuf.Done THEN&#xD;
            Wrk_State := 50;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
        ELSIF Wrk_SktTLSClearBuf.Error THEN&#xD;
            Wrk_State := 80; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1040_0001;&#xD;
		ELSIF Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
			Wrk_State := 80; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1040_0002;&#xD;
        END_IF;&#xD;
&#xD;
&#xD;
	//SktTLSWrite&#xD;
    50: &#xD;
		Wrk_SendString := HE_RT100BuildRequest(Inp_Command := '/tshoot?format=text&amp;filter=ifaces',&#xD;
			 Cfg_RT100_IPaddress := Cfg_IP_Adresse,&#xD;
			 Cfg_Port := Cfg_Port,&#xD;
			 Cfg_Auth := Cfg_Auth);&#xD;
		ToAryByte(Wrk_SendString, _LOW_HIGH, Wrk_SendData[0]);&#xD;
		Wrk_SendSize :=GetByteLen(In:=Wrk_SendString);&#xD;
        Wrk_TLSSend := TRUE;&#xD;
		&#xD;
		Wrk_State := 51;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
		&#xD;
	51:&#xD;
        IF Wrk_SktTLSWrite.Done THEN&#xD;
            Wrk_State := 60;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		ELSIF NOT Wrk_SktTLSWrite.Busy THEN&#xD;
			Wrk_State := 80;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1051_0001;&#xD;
        ELSIF  Wrk_SktTLSWrite.Error THEN&#xD;
              Wrk_State := 80; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1051_0002;&#xD;
		ELSIF Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
			Wrk_State := 80; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1051_0003;&#xD;
        END_IF;&#xD;
&#xD;
&#xD;
	//SktTLSRead&#xD;
    60:&#xD;
        Wrk_TLSRecv := TRUE;&#xD;
		&#xD;
		Wrk_State := 61;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
		&#xD;
	61:&#xD;
        IF Wrk_SktTLSRead.Done THEN&#xD;
			Wrk_RecvString:= AryToString(In:=Wrk_RecvData[0], Size :=Min(SizeOfAry( In:=Wrk_RecvData ), UINT#1985));&#xD;
			IF 0 &lt; FIND(In1:=Wrk_RecvString, In2:='200 OK') THEN&#xD;
	            Wrk_State := 70;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			ELSE&#xD;
				Wrk_State := 80;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
				Wrk_ErrorCode := 16#1061_0001;&#xD;
			END_IF;&#xD;
		ELSIF NOT Wrk_SktTLSRead.Busy THEN&#xD;
			Wrk_State := 80;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1061_0002;&#xD;
        ELSIF Wrk_SktTLSRead.Error THEN&#xD;
            Wrk_State := 80; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1061_0003;&#xD;
		ELSIF Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
			Wrk_State := 80; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1061_0004;&#xD;
        END_IF;&#xD;
	&#xD;
	// Parse Data&#xD;
	70:&#xD;
		&#xD;
		IF HE_RT100ParseIfaces(&#xD;
			Inp_RecvString := Wrk_RecvString,&#xD;
			Out_LinkState =&gt; Wrk_LinkState,&#xD;
			Out_WirelessGen =&gt; Wrk_WirelessGen,&#xD;
			Out_Operator =&gt; Wrk_Operator,&#xD;
			Out_Signal =&gt; Wrk_Signal)&#xD;
		THEN&#xD;
			Out_LinkState := Wrk_LinkState;&#xD;
			Out_WirelessGen := Wrk_WirelessGen;&#xD;
			Out_Operator := Wrk_Operator;&#xD;
			Out_Signal := Wrk_Signal;&#xD;
		END_IF;&#xD;
		Wrk_State := 80;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
		&#xD;
	//SktTLSDisconnect&#xD;
    80:&#xD;
        Wrk_EndTLSSession := TRUE;&#xD;
		&#xD;
        IF Wrk_SktTLSDisconnect.Done THEN&#xD;
            Wrk_State := 90;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
        ELSIF Wrk_SktTLSDisconnect.Error THEN&#xD;
             Wrk_State := 90; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1080_0001;&#xD;
		ELSIF Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
			Wrk_State := 90; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1080_0002;&#xD;
        END_IF;&#xD;
&#xD;
    90: //SktClose&#xD;
        Wrk_CloseSocket := TRUE;&#xD;
		&#xD;
        IF Wrk_SktClose.Done THEN&#xD;
            Wrk_State := 10;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
        ELSIF Wrk_SktClose.Error THEN&#xD;
            Wrk_State := 10; &#xD;
			Wrk_TimeInState := T#0s;&#xD;
			Wrk_ErrorCode := 16#1090_0001;&#xD;
        END_IF;&#xD;
		&#xD;
ELSE&#xD;
	Wrk_State := 0;&#xD;
	Wrk_TimeInState := T#0s;&#xD;
	Wrk_ErrorCode := 16#FFFF_FFFF;&#xD;
		&#xD;
END_CASE;&#xD;
&#xD;
&#xD;
 // Get Interval Time&#xD;
 Wrk_TaskIntervalTime := GetMyTaskInterval();&#xD;
 // Increment state time&#xD;
 Wrk_TimeInState :=  ADD_TIME(In1:=Wrk_TimeInState, In2:=Wrk_TaskIntervalTime);&#xD;
&#xD;
&#xD;
Wrk_SktTCPConnect(&#xD;
    Execute :=Wrk_TCP_Connect,&#xD;
    SrcTcpPort :=UINT#0, //own TCP port number(auto allocation)&#xD;
    DstAdr :=Cfg_IP_Adresse, //target IP Address or host name&#xD;
    DstTcpPort :=Cfg_Port, //target TCP port number&#xD;
    Socket =&gt;Wrk_Socket ); //socket variable&#xD;
&#xD;
Wrk_SktTLSConnect(&#xD;
    Execute :=Wrk_EstTLSSession,&#xD;
    Socket :=Wrk_Socket, //socket variable&#xD;
    TLSSessionName :=Cfg_TLSSession, //TLS session name&#xD;
    Handle =&gt;Wrk_SessionHandle ); //TLS session handle&#xD;
	&#xD;
Wrk_SktTLSClearBuf(&#xD;
    Execute :=Wrk_SktClearBuffer,&#xD;
    Handle :=Wrk_SessionHandle); //TLS session handle&#xD;
	&#xD;
Wrk_SktTLSWrite(&#xD;
    Execute :=Wrk_TLSSend,&#xD;
    Handle :=Wrk_SessionHandle, //TLS session handle&#xD;
    SendDat :=Wrk_SendData[0], //sending data&#xD;
    SendDatSize :=Wrk_SendSize ); //sending data size&#xD;
	&#xD;
Wrk_SktTLSRead(&#xD;
    Execute :=Wrk_TLSRecv,&#xD;
    Handle :=Wrk_SessionHandle, //TLS session handle&#xD;
    TimeOut :=TLS_TIMEOUT, //timeout time&#xD;
    RcvDatSize :=SizeOfAry( In:=Wrk_RecvData ), //receive buffer size&#xD;
    RcvDat :=Wrk_RecvData[0], //receiving data&#xD;
    RcvSize =&gt;Wrk_RecvSize ); //receiving data size&#xD;
	&#xD;
Wrk_SktTLSDisconnect(&#xD;
    Execute :=Wrk_EndTLSSession,&#xD;
    Handle :=Wrk_SessionHandle ); //TLS session handle&#xD;
	&#xD;
Wrk_SktClose(&#xD;
    Execute :=Wrk_CloseSocket,&#xD;
    Socket :=Wrk_Socket ); //socket variable&#xD;
	&#xD;
// Clear Execution bits&#xD;
Wrk_TCP_Connect :=FALSE;&#xD;
Wrk_EstTLSSession := FALSE;&#xD;
Wrk_SktClearBuffer := FALSE;&#xD;
Wrk_TLSSend := FALSE;&#xD;
Wrk_TLSRecv := FALSE;&#xD;
Wrk_EndTLSSession := FALSE;&#xD;
Wrk_CloseSocket := FALSE;&#xD;
&#xD;
Sts_ConnectionError := Wrk_ConnectionError;</Text></StructuredTextModel>