<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//	NAME:					HE_SNMP_Decode&#xD;
//	CREATOR:				Helgevold - Jan Magne Dybvik&#xD;
// REQUIREMENTS: NX CPU&#xD;
//&#xD;
// DESCRTIPTION: 	Dekoder SNMP Respons data&#xD;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//  VERSION LOG:&#xD;
//	 VERSION			DATE				SIGN							DESCRIPTION&#xD;
//	 1.0.0				2024-05-15		Jan Magne Dybvik		Initial release&#xD;
//&#xD;
//================================================================================================================================&#xD;
&#xD;
Wrk_BufferUB := UPPER_BOUND(Ext_Buffer, 1);&#xD;
Wrk_BufferLB := LOWER_BOUND(Ext_Buffer, 1);&#xD;
Wrk_ReamainingBuffer := Wrk_BufferUB - Ext_BufferOffset;&#xD;
HE_SNMP_Decode := FALSE;&#xD;
	Out_Integer := 0;&#xD;
	Out_String := '';&#xD;
&#xD;
// Check that datatype and data length bytes are in bounds&#xD;
IF UINT_TO_DINT(Ext_BufferOffset) &lt; Wrk_BufferLB  AND (UINT_TO_DINT(Ext_BufferOffset + 1) &gt; Wrk_BufferUB) THEN&#xD;
	RETURN;&#xD;
END_IF;&#xD;
&#xD;
Wrk_DataType := BYTE_TO_USINT(Ext_Buffer[Ext_BufferOffset]);&#xD;
Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
Wrk_ValueLen := BYTE_TO_USINT(Ext_Buffer[Ext_BufferOffset]);&#xD;
Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
 &#xD;
// Check that the value is in bounds&#xD;
IF UINT_TO_DINT(Ext_BufferOffset + Wrk_ValueLen) &gt;= Wrk_BufferUB THEN&#xD;
	RETURN;&#xD;
END_IF;&#xD;
&#xD;
CASE Wrk_DataType OF // check data type&#xD;
	16#02: // Integer type&#xD;
	&#xD;
		IF (Ext_Buffer[Ext_BufferOffset] AND 16#80) = 0 THEN	 // Positive integer&#xD;
			&#xD;
			CASE Wrk_ValueLen OF&#xD;
				1:&#xD;
					Wrk_Val := BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					IF (Wrk_Val AND DWORD#16#80) &lt;&gt; 0 THEN&#xD;
						Wrk_Val := NOT(Wrk_Val);&#xD;
					END_IF;&#xD;
				2:&#xD;
					Wrk_Val := BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := SHL(Wrk_Val, 8) OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					IF (Wrk_Val AND DWORD#16#8000) &lt;&gt; 0 THEN&#xD;
						Wrk_Val := NOT(Wrk_Val);&#xD;
					END_IF;&#xD;
				3:&#xD;
					Wrk_Val := BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := SHL(Wrk_Val, 8) OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := SHL(Wrk_Val, 8) OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					IF (Wrk_Val AND DWORD#16#800000) &lt;&gt; 0 THEN&#xD;
						Wrk_Val := NOT(Wrk_Val);&#xD;
					END_IF;&#xD;
				4:&#xD;
					Wrk_Val := BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := SHL(Wrk_Val, 8) OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := SHL(Wrk_Val, 8) OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := SHL(Wrk_Val, 8) OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
&#xD;
			END_CASE;&#xD;
			&#xD;
		ELSE // Negative integer&#xD;
			&#xD;
			CASE Wrk_ValueLen OF&#xD;
				1: &#xD;
					Wrk_Val := DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					&#xD;
				2:&#xD;
					Wrk_Val := ROL(DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]), 8);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := Wrk_Val AND DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					&#xD;
				3:&#xD;
					Wrk_Val := ROL(DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]), 16);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := Wrk_Val AND ROL(DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]), 8);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := Wrk_Val AND DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					&#xD;
				4:&#xD;
					Wrk_Val := ROL(DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]), 24);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := Wrk_Val AND ROL(DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]), 16);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := Wrk_Val AND ROL(DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]), 8);&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					Wrk_Val := Wrk_Val AND (DWORD#16#FFFFFF00 OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset]));&#xD;
					Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
					&#xD;
				&#xD;
			END_CASE;&#xD;
			&#xD;
		END_IF;&#xD;
		Out_Integer := DWORD_TO_UDINT(Wrk_Val);	&#xD;
		&#xD;
		&#xD;
	16#04: // String type&#xD;
		Out_String := AryToString(In:=Ext_Buffer[Ext_BufferOffset], Size:=Wrk_ValueLen);&#xD;
		Ext_BufferOffset := Ext_BufferOffset + Wrk_ValueLen;&#xD;
	&#xD;
	16#06:	// Objekt indentifiseringsverdi&#xD;
		Out_String := USINT_TO_STRING(In:= BYTE_TO_USINT(Ext_Buffer[Ext_BufferOffset]) / 40);&#xD;
		Out_String := CONCAT(In1:=Out_String, In2:='.');&#xD;
		Out_String := CONCAT(In1:=Out_String, In2:=USINT_TO_STRING(In:=BYTE_TO_USINT(Ext_Buffer[Ext_BufferOffset]) MOD 40));&#xD;
		Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
		&#xD;
		Wrk_i :=1;&#xD;
		REPEAT &#xD;
		    Out_String := CONCAT(In1:=Out_String, In2:='.');&#xD;
			Wrk_Val := 0;&#xD;
			&#xD;
			// if MSB is set following byte is also used (7 bits)&#xD;
			WHILE  (Ext_Buffer[Ext_BufferOffset] &amp; 16#80) &lt;&gt; 16#0 DO&#xD;
				Wrk_Val :=Wrk_Val OR BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset] &amp; 16#7F);&#xD;
				Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
				Wrk_i :=Wrk_i + 1;&#xD;
				Wrk_Val :=SHL(Wrk_Val, 7);&#xD;
			END_WHILE;&#xD;
			&#xD;
			Wrk_Val := Wrk_Val OR (BYTE_TO_DWORD(Ext_Buffer[Ext_BufferOffset] &amp; 16#7F));&#xD;
			Ext_BufferOffset := Ext_BufferOffset + 1;&#xD;
			Out_String := CONCAT(In1:=Out_String, In2:=UINT_TO_STRING(In:=DWORD_TO_UINT(Wrk_Val)));&#xD;
			Wrk_i :=Wrk_i + 1;&#xD;
		UNTIL Wrk_i &gt;= Wrk_ValueLen&#xD;
		END_REPEAT;&#xD;
END_CASE;&#xD;
	&#xD;
HE_SNMP_Decode := TRUE;</Text></StructuredTextModel>