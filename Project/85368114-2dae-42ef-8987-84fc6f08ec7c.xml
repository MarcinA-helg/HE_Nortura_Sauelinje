<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//	NAME:					HE_SNMP_EncodeInteger&#xD;
//	CREATOR:				Helgevold - Jan Magne Dybvik&#xD;
// REQUIREMENTS: NX CPU&#xD;
//&#xD;
// DESCRTIPTION: 	Koder SNMP Integerverdi&#xD;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//  VERSION LOG:&#xD;
//	 VERSION			DATE				SIGN							DESCRIPTION&#xD;
//	 1.0.0				2024-05-15		Jan Magne Dybvik		Initial release&#xD;
//&#xD;
//================================================================================================================================&#xD;
&#xD;
// Initalize&#xD;
Wrk_BufferUB := UPPER_BOUND(Ext_Buffer, 1);&#xD;
Wrk_BufferLB := LOWER_BOUND(Ext_Buffer, 1);&#xD;
Wrk_ExtBufferSize := Wrk_BufferUB - Wrk_BufferLB + 1;&#xD;
Wrk_Size := 0;&#xD;
&#xD;
// Type: Integer&#xD;
Wrk_Buffer[0] := 16#02;&#xD;
&#xD;
ToAryByte(Inp_Value, _LOW_HIGH, Wrk_ValueBuffer[0]);		// Convert integer to bytearray&#xD;
&#xD;
// Determine number of bytes needed&#xD;
IF DWORD_TO_DINT(Inp_Value) &gt;= 0 THEN // Positive value&#xD;
	IF Inp_Value &gt; 16#FFFFFF THEN	// 4 bytes&#xD;
		Wrk_Buffer[2] := Wrk_ValueBuffer[3];&#xD;
		Wrk_Buffer[3] := Wrk_ValueBuffer[2];&#xD;
		Wrk_Buffer[4] := Wrk_ValueBuffer[1];&#xD;
		Wrk_Buffer[5] := Wrk_ValueBuffer[0];&#xD;
		Wrk_ValueSize := 4;&#xD;
		&#xD;
	ELSIF Inp_Value &gt; 16#FFFF THEN	// 3 bytes&#xD;
		IF (Wrk_ValueBuffer[2] AND 16#80) = 0 THEN&#xD;
			Wrk_Buffer[2] := Wrk_ValueBuffer[2];&#xD;
			Wrk_Buffer[3] := Wrk_ValueBuffer[1];&#xD;
			Wrk_Buffer[4] := Wrk_ValueBuffer[0];&#xD;
			Wrk_Buffer[5] := 0;&#xD;
			Wrk_ValueSize := 3;&#xD;
		ELSE // Padding&#xD;
			Wrk_Buffer[2] := 0;&#xD;
			Wrk_Buffer[3] := Wrk_ValueBuffer[2];&#xD;
			Wrk_Buffer[4] := Wrk_ValueBuffer[1];&#xD;
			Wrk_Buffer[5] := Wrk_ValueBuffer[0];&#xD;
			Wrk_ValueSize := 4;&#xD;
		END_IF;&#xD;
&#xD;
	ELSIF Inp_Value &gt; 16#FF THEN	// 2 bytes&#xD;
		IF (Wrk_ValueBuffer[1] AND 16#80) = 0 THEN&#xD;
			Wrk_Buffer[2] := Wrk_ValueBuffer[1];&#xD;
			Wrk_Buffer[3] := Wrk_ValueBuffer[0];&#xD;
			Wrk_Buffer[4] := 0;&#xD;
			Wrk_Buffer[5] := 0;&#xD;
			Wrk_ValueSize := 2;&#xD;
		ELSE // Padding&#xD;
			Wrk_Buffer[2] := 0;&#xD;
			Wrk_Buffer[3] := Wrk_ValueBuffer[1];&#xD;
			Wrk_Buffer[4] := Wrk_ValueBuffer[0];&#xD;
			Wrk_Buffer[5] := 0;&#xD;
			Wrk_ValueSize := 3;&#xD;
		END_IF;&#xD;
&#xD;
	ELSE												// 1 byte&#xD;
		IF (Wrk_ValueBuffer[0] AND 16#80) = 0 THEN&#xD;
			Wrk_Buffer[2] := Wrk_ValueBuffer[0];&#xD;
			Wrk_Buffer[3] := 0;&#xD;
			Wrk_Buffer[4] := 0;&#xD;
			Wrk_Buffer[5] := 0;&#xD;
			Wrk_ValueSize := 1;&#xD;
		ELSE // Padding&#xD;
			Wrk_Buffer[2] := 0;&#xD;
			Wrk_Buffer[3] := Wrk_ValueBuffer[0];&#xD;
			Wrk_Buffer[4] := 0;&#xD;
			Wrk_Buffer[5] := 0;&#xD;
			Wrk_ValueSize := 2;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
&#xD;
ELSE // Negative value&#xD;
	IF (Inp_Value AND 16#FFFFFF80) = 16#FFFFFF80 THEN	// 1 bytes&#xD;
		Wrk_Buffer[2] := Wrk_ValueBuffer[0];&#xD;
		Wrk_Buffer[3] := 0;&#xD;
		Wrk_Buffer[4] := 0;&#xD;
		Wrk_Buffer[5] := 0;&#xD;
		Wrk_ValueSize := 1;&#xD;
		&#xD;
	ELSIF  (Inp_Value AND 16#FFFF8000) = 16#FFFF8000 THEN	// 2 bytes&#xD;
		Wrk_Buffer[2] := Wrk_ValueBuffer[1];&#xD;
		Wrk_Buffer[3] := Wrk_ValueBuffer[0];&#xD;
		Wrk_Buffer[4] := 0;&#xD;
		Wrk_Buffer[5] := 0;&#xD;
		Wrk_ValueSize := 2;&#xD;
&#xD;
	ELSIF  (Inp_Value AND 16#FF800000) = 16#FF800000 THEN	// 3 bytes&#xD;
		Wrk_Buffer[2] := Wrk_ValueBuffer[2];&#xD;
		Wrk_Buffer[3] := Wrk_ValueBuffer[1];&#xD;
		Wrk_Buffer[4] := Wrk_ValueBuffer[0];&#xD;
		Wrk_Buffer[5] := 0;&#xD;
		Wrk_ValueSize := 3;&#xD;
	ELSE&#xD;
		Wrk_Buffer[2] := Wrk_ValueBuffer[3];&#xD;
		Wrk_Buffer[3] := Wrk_ValueBuffer[2];&#xD;
		Wrk_Buffer[4] := Wrk_ValueBuffer[1];&#xD;
		Wrk_Buffer[5] := Wrk_ValueBuffer[0];&#xD;
		Wrk_ValueSize := 4;&#xD;
		&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
Wrk_Buffer[1] := USINT_TO_BYTE(Wrk_ValueSize);&#xD;
&#xD;
// Copy object to external buffer&#xD;
Wrk_Size := Wrk_ValueSize + 2;	// Number of bytes to copy&#xD;
IF Wrk_Size &lt;= Wrk_ExtBufferSize THEN	// External buffer has space&#xD;
	MemCopy(In:=Wrk_Buffer[0], AryOut:=Ext_Buffer[Wrk_BufferLB], Size:=Wrk_Size);&#xD;
ELSE&#xD;
	Wrk_Size := 0;&#xD;
END_IF;&#xD;
&#xD;
HE_SNMP_EncodeInteger := Wrk_Size;	// Return number of bytes added to external array&#xD;
</Text></StructuredTextModel>