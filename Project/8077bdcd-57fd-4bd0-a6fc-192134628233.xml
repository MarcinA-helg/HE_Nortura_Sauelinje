<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//	NAME:			HE_LightControl                                                                                                                                                                                                                                                                           &#xD;
//	CREATOR:		Helgevold - William Veim                                                                                                                                                                                                                                                              &#xD;
//                                                                                                                                                                                                                                                                                                                            &#xD;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//  VERSION LOG:                                                                                                                                                                                                                                                                                                   &#xD;
//	VERSION		DATE				SIGN						DESCRIPTION                                                                                                                                                                                     &#xD;
//	1.0.0				2025-03-03		William Veim			Initial release&#xD;
//	2.0.0				2025-03-03		William Veim			Rework&#xD;
//	2.0.1				2025-04-29		Ruben Byman			Added alarm trigger and bug fix state control&#xD;
//	2.0.2				2025-05-06		Ruben Byman			Changed time of day inputs from SCADA from STRING to 2x INTs and expanded STRING EndTime to format "17:59"&#xD;
//&#xD;
//===============================================================================================================================&#xD;
//&#xD;
//		DESCRIPTION:&#xD;
//		Block for light control based on start time and desired light duration. Option to increase light duration per day. Outputs as analog and digital values.&#xD;
//&#xD;
//==============================================================================================================================&#xD;
&#xD;
//Retrieves current clock from PLC&#xD;
Time_Current := TruncTod(DT_TO_TOD(In:=GetTime()), _SEC);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	Criteria for starting up and down dimming&#xD;
 *************************************************************************)&#xD;
//If the light duration is shorter than the total dimming time, the light duration is adjusted accordingly&#xD;
IF HE_INT2Minute(Hour:=Ext_LightControl.EXT_Operator.LightDuration_Hour, Minute:=Ext_LightControl.EXT_Operator.LightDuration_Minute) &lt; (Ext_LightControl.EXT_Operator.DimUp_Time+Ext_LightControl.EXT_Operator.DimDown_Time) THEN&#xD;
	Wrk_TotalDimmingTime := HE_Sec2Str((Ext_LightControl.EXT_Operator.DimUp_Time+Ext_LightControl.EXT_Operator.DimDown_Time)*60);&#xD;
	Ext_LightControl.EXT_Operator.LightDuration_Hour := STRING_TO_INT(LEFT(In:=Wrk_TotalDimmingTime, L:=2));&#xD;
	Ext_LightControl.EXT_Operator.LightDuration_Minute := STRING_TO_INT(RIGHT(In:=Wrk_TotalDimmingTime, L:=2));&#xD;
END_IF;&#xD;
&#xD;
Ext_LightControl.EXT_Operator.EndTime := LEFT(TodToString(Time_End),5);&#xD;
&#xD;
Time_End 			:= ADD_TOD_TIME(Time_DimUp, HE_INT2TIME(Hour:=Ext_LightControl.EXT_Operator.LightDuration_Hour, Minute:=Ext_LightControl.EXT_Operator.LightDuration_Minute));&#xD;
Time_DimDown 	:= SUB_TOD_TIME(Time_End, SecToTime(Ext_LightControl.EXT_Operator.DimDown_Time*60));&#xD;
Time_DimUp 		:= HE_INT2TOD(Hour:=Ext_LightControl.EXT_Operator.StartTime_Hour, Minute:=Ext_LightControl.EXT_Operator.StartTime_Minute);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	Light control/management&#xD;
 *************************************************************************)&#xD;
 //Timer for stepwise up-dimming&#xD;
TON_Dim(PT:=Time_DimPulse);&#xD;
&#xD;
//Checks if the time for dimming down is before midnight&#xD;
IF Time_DimUp &lt; Time_DimDown THEN&#xD;
	//Checks if it is outside the light time&#xD;
	IF Time_Current &gt; Time_DimDown OR Time_Current &lt; Time_DimUp THEN&#xD;
		Within_Light_Time := FALSE;&#xD;
	ELSE&#xD;
		Within_Light_Time := TRUE;&#xD;
	END_IF;&#xD;
// Time for dimming down is after midnight&#xD;
ELSE&#xD;
	//Checks if it is outside the light time&#xD;
	IF Time_Current &gt; Time_DimDown AND Time_Current &lt; Time_DimUp THEN&#xD;
		Within_Light_Time := FALSE;&#xD;
	ELSE&#xD;
		Within_Light_Time := TRUE;&#xD;
	END_IF;&#xD;
END_IF;&#xD;
&#xD;
//Pauses light control in case of communication error&#xD;
IF NOT Inp_ExtFault THEN&#xD;
	&#xD;
	IF NOT Inp_Voltage_State THEN&#xD;
		LightControl_Step := Standby;&#xD;
	END_IF;&#xD;
	&#xD;
	CASE LightControl_Step OF&#xD;
		&#xD;
		Standby:&#xD;
				Ext_LightControl.EXT_Operator.Auto_Output := 0;&#xD;
				&#xD;
				// Dims up if within light time&#xD;
				IF Within_Light_Time AND Inp_Voltage_State THEN&#xD;
					LightControl_Step := DimUp;&#xD;
				END_IF;&#xD;
				&#xD;
				IF RE_Standby.Q THEN&#xD;
					//Adds the desired increase in light duration&#xD;
					Wrk_NewDuration := HE_INTAdd(Inn1_Hour:=Ext_LightControl.EXT_Operator.LightDuration_Hour, Inn1_Minute:=Ext_LightControl.EXT_Operator.LightDuration_Minute, Inn2:=Ext_LightControl.EXT_Engineering.MinuteIncrease_PerDay);&#xD;
					Ext_LightControl.EXT_Operator.LightDuration_Hour := STRING_TO_INT(LEFT(In:=Wrk_NewDuration, L:=2));&#xD;
					Ext_LightControl.EXT_Operator.LightDuration_Minute := STRING_TO_INT(RIGHT(In:=Wrk_NewDuration, L:=2));&#xD;
					//Increases maximum output&#xD;
					Ext_LightControl.EXT_Engineering.MaxGain := Ext_LightControl.EXT_Engineering.MaxGain+Ext_LightControl.EXT_Engineering.MaxGainIncrease_PerDay;&#xD;
					IF Ext_LightControl.EXT_Engineering.MaxGain &gt; 100 THEN&#xD;
						Ext_LightControl.EXT_Engineering.MaxGain := 100;&#xD;
					END_IF;&#xD;
					//Reduces minimum output&#xD;
					Ext_LightControl.EXT_Engineering.MinGain := Ext_LightControl.EXT_Engineering.MinGain - Ext_LightControl.EXT_Engineering.MinGainDecrease_PerDay;&#xD;
					IF Ext_LightControl.EXT_Engineering.MinGain &lt; 0 THEN&#xD;
						Ext_LightControl.EXT_Engineering.MinGain := 0;&#xD;
					END_IF;&#xD;
				END_IF;&#xD;
&#xD;
	    DimUp:&#xD;
				// Calculates the required time between each step of up-dimming&#xD;
				Time_DimPulse := NanoSecToTime((Ext_LightControl.EXT_Operator.DimUp_Time* (100/(Ext_LightControl.EXT_Engineering.MaxGain-Ext_LightControl.EXT_Engineering.MinGain))*60)*10**5);&#xD;
					&#xD;
				// When the timer has run, increments output (+1) and resets the timer&#xD;
				IF TON_Dim.Q THEN&#xD;
					Gain_Auto:=Gain_Auto+ 0.01;&#xD;
					TON_Dim.In := FALSE;&#xD;
				ELSE&#xD;
					TON_Dim.In := TRUE;&#xD;
				END_IF;&#xD;
				&#xD;
				//When the output has reached the set value, up-dimming stops&#xD;
				IF Gain_Auto &gt;= Ext_LightControl.EXT_Engineering.MaxGain THEN&#xD;
					Gain_Auto := Ext_LightControl.EXT_Engineering.MaxGain;&#xD;
					LightControl_Step := FullBrightness;&#xD;
				END_IF;&#xD;
				&#xD;
		FullBrightness:&#xD;
	&#xD;
				//Dims down outside light time, except for 24-hour light time&#xD;
				IF NOT Within_Light_Time AND (HE_INT2TIME(Hour:=Ext_LightControl.EXT_Operator.LightDuration_Hour, Minute:=Ext_LightControl.EXT_Operator.LightDuration_Minute) &lt;&gt; TIME#24h) THEN&#xD;
					LightControl_Step := DimDown;&#xD;
				END_IF;&#xD;
				&#xD;
		DimDown:&#xD;
				//Calculates the required time between each step of down-dimming&#xD;
				Time_DimPulse := NanoSecToTime((Ext_LightControl.EXT_Operator.DimDown_Time * (100/(Ext_LightControl.EXT_Engineering.MaxGain-Ext_LightControl.EXT_Engineering.MinGain))*60)*10**5);&#xD;
				&#xD;
				//When the timer has run, decrements output (-1) and resets the timer&#xD;
				IF TON_Dim.Q AND Ext_LightControl.EXT_Operator.Auto_Output &gt; Ext_LightControl.EXT_Engineering.MinGain THEN&#xD;
					Gain_Auto := Gain_Auto- 0.01;&#xD;
					TON_Dim.In := FALSE;&#xD;
				ELSE&#xD;
					TON_Dim.In := TRUE;&#xD;
				END_IF;&#xD;
				&#xD;
				//When the output reaches zero, down-dimming stops and updates variables&#xD;
				IF Gain_Auto &lt;= Ext_LightControl.EXT_Engineering.MinGain THEN&#xD;
					Gain_Auto := Ext_LightControl.EXT_Engineering.MinGain;&#xD;
					RE_Standby(Clk:=TRUE);&#xD;
					LightControl_Step := Standby;&#xD;
				ELSE&#xD;
					RE_Standby(Clk:=FALSE);&#xD;
				END_IF;&#xD;
				&#xD;
	END_CASE;	&#xD;
END_IF;&#xD;
		&#xD;
//Updates output&#xD;
IF NOT Inp_Voltage_State THEN&#xD;
	Gain_Auto:=0.0;&#xD;
ELSE&#xD;
	Ext_LightControl.EXT_Operator.Auto_Output:=ScaleTrans(SclIn:=Gain_Auto, &#xD;
																							X0:=0, &#xD;
																							Y0:=Ext_LightControl.EXT_Engineering.MinGain, &#xD;
																							X1:=100, &#xD;
																							Y1:=Ext_LightControl.EXT_Engineering.MaxGain);;&#xD;
END_IF;		&#xD;
		&#xD;
(*************************************************************************&#xD;
 *	Retrieves output based on mode&#xD;
 *************************************************************************)				&#xD;
CASE Ext_LightControl.EXT_Operator.Mode OF&#xD;
	&#xD;
    0://Off&#xD;
			//Updates output&#xD;
			Wrk_Output := 0;&#xD;
			&#xD;
	1://Man&#xD;
			//Updates output&#xD;
			Wrk_Output := Ext_LightControl.EXT_Operator.Manual_Output;&#xD;
			&#xD;
	2://Auto&#xD;
			Wrk_Output := Ext_LightControl.EXT_Operator.Auto_Output;&#xD;
			&#xD;
END_CASE;&#xD;
		&#xD;
		&#xD;
//FAULT CONTROL&#xD;
//---------------------------&#xD;
Wrk_ExternalFault:=Inp_ExtFault;&#xD;
Wrk_Interlock:=Inp_Interlock;&#xD;
Wrk_ConfigFault:=Ext_LightControl.EXT_Engineering.MinGain=Ext_LightControl.EXT_Engineering.MaxGain OR Ext_LightControl.EXT_Operator.DimDown_Time = 0 OR Ext_LightControl.EXT_Operator.DimUp_Time = 0;&#xD;
&#xD;
// STATE CONTROL&#xD;
//------------------&#xD;
&#xD;
//Resetter variabler før løkke&#xD;
Ext_LightControl.EXT_General.Sts_Quality := 0;&#xD;
Wrk_ValueState:=	0;&#xD;
Wrk_AlarmState:=	FALSE;&#xD;
Wrk_AlarmSuffix:=	'';&#xD;
&#xD;
//External fault&#xD;
Ext_LightControl.EXT_Engineering.StateCfg_1.Sts_State := Wrk_ExternalFault;&#xD;
Ext_LightControl.EXT_Engineering.StateCfg_1.Sts_Desc := 'External fault';&#xD;
HE_StateControl(Inp_StateData:=Ext_LightControl.EXT_Engineering.StateCfg_1, &#xD;
							Sts_Quality:=Ext_LightControl.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
				&#xD;
//Config fault&#xD;
Ext_LightControl.EXT_Engineering.StateCfg_2.Sts_State := Wrk_ConfigFault;&#xD;
Ext_LightControl.EXT_Engineering.StateCfg_2.Sts_Desc := 'Configuration fault';&#xD;
HE_StateControl(Inp_StateData:=Ext_LightControl.EXT_Engineering.StateCfg_2, &#xD;
							Sts_Quality:=Ext_LightControl.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
&#xD;
//Interlock&#xD;
Ext_LightControl.EXT_Engineering.StateCfg_3.Sts_State := Wrk_Interlock;&#xD;
Ext_LightControl.EXT_Engineering.StateCfg_3.Sts_Desc := 'Interlock';&#xD;
HE_StateControl(Inp_StateData:=Ext_LightControl.EXT_Engineering.StateCfg_3, &#xD;
							Sts_Quality:=Ext_LightControl.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_LightControl.EXT_Engineering.StateCfg_3.Sts_Visible:=Cfg_Interlock_InUse; //Only visible if interlock in use			&#xD;
			&#xD;
CASE Wrk_ValueState OF&#xD;
	&#xD;
	0://Use value&#xD;
	Ext_LightControl.EXT_Operator.Actual_Output := Wrk_Output;&#xD;
	&#xD;
	1://Hold value&#xD;
	Ext_LightControl.EXT_Operator.Actual_Output := Ext_LightControl.EXT_Operator.Actual_Output;&#xD;
	&#xD;
	2://Pre defined output&#xD;
	Ext_LightControl.EXT_Operator.Actual_Output :=Ext_LightControl.EXT_Engineering.StateCfg_PreDefinedOutput;&#xD;
	&#xD;
END_CASE;&#xD;
	&#xD;
// ALARM CONTROL&#xD;
//------------------&#xD;
Wrk_AlarmGeneral.Inp_Connected_Cabinet:=				Cfg_ControlCabinet;&#xD;
Wrk_AlarmGeneral.Inp_Connected_Controller:=				Cfg_ControllerTAG;&#xD;
Wrk_AlarmGeneral.Inp_Process_Desc:=							Ext_LightControl.EXT_General.Process_Desc;&#xD;
Wrk_AlarmGeneral.Inp_Process_Suffix:=							Wrk_AlarmSuffix;&#xD;
Wrk_AlarmGeneral.Inp_Process_TAG:=							'';&#xD;
Wrk_AlarmGeneral.Inp_Process_Value:=							'';&#xD;
Wrk_AlarmGeneral.Inp_Trigger:=										Wrk_AlarmState;&#xD;
&#xD;
Wrk_AlarmGeneral(ENS:=TRUE, &#xD;
								Ext_Alarm:=Ext_LightControl.EXT_Alarm, &#xD;
								Int_Alarm:=Int_Alarm);	&#xD;
	&#xD;
(*************************************************************************&#xD;
 *	UPDATE OUTPUT&#xD;
 *************************************************************************)			&#xD;
 &#xD;
//Outputs on block&#xD;
//-------------------------&#xD;
Sts_LightStarted 	:= Ext_LightControl.EXT_Operator.Actual_Output &gt; 0;&#xD;
Sts_LightMax 			:= Ext_LightControl.EXT_Operator.Actual_Output = Ext_LightControl.EXT_Engineering.MaxGain;&#xD;
&#xD;
Out_ByteOutput := REAL_TO_BYTE(ScaleTrans(SclIn:=Ext_LightControl.EXT_Operator.Actual_Output, &#xD;
			X0:=0.0, &#xD;
			Y0:=0.0, &#xD;
			X1:=100.0, &#xD;
			Y1:=254.0));&#xD;
&#xD;
//Oppdaterer intern struktur&#xD;
Ext_LightControl.INT_Data.DimDown_Started := LightControl_Step = DimDown;&#xD;
Ext_LightControl.INT_Data.DimUp_Started := LightControl_Step = DimUp;&#xD;
Ext_LightControl.INT_Data.LightMax := Sts_LightMax;&#xD;
&#xD;
//Oppdaterer status streng&#xD;
IF Ext_LightControl.EXT_Operator.Mode = 0 THEN&#xD;
	Ext_LightControl.EXT_General.StateDesc := 'Off mode - light is off';&#xD;
END_IF;&#xD;
IF Ext_LightControl.EXT_Operator.Mode = 1 THEN&#xD;
	Ext_LightControl.EXT_General.StateDesc := 'Manual mode - light follows manual gain';&#xD;
END_IF;&#xD;
IF Ext_LightControl.EXT_Operator.Mode = 2 THEN&#xD;
	IF LightControl_Step = DimUp THEN&#xD;
		Ext_LightControl.EXT_General.StateDesc := 'Auto mode - Dims up light';&#xD;
	ELSIF LightControl_Step = DimDown THEN&#xD;
		Ext_LightControl.EXT_General.StateDesc := 'Auto mode - Dims down light';&#xD;
	ELSIF LightControl_Step = FullBrightness THEN&#xD;
		Ext_LightControl.EXT_General.StateDesc := 'Auto mode - Full brightness achieved';&#xD;
	ELSIF LightControl_Step = Standby THEN&#xD;
		Ext_LightControl.EXT_General.StateDesc := 'Auto mode - Standby';&#xD;
	END_IF;&#xD;
END_IF;&#xD;
IF NOT Inp_Voltage_State THEN&#xD;
	Ext_LightControl.EXT_General.StateDesc := 'Standby mode - voltage state fault';&#xD;
END_IF;&#xD;
IF Inp_ExtFault THEN&#xD;
	Ext_LightControl.EXT_General.StateDesc := 'Standby mode - communication fault';&#xD;
END_IF;&#xD;
</Text></StructuredTextModel>