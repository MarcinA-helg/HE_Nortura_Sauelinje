<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//	NAME:					HE_SNMP_Get&#xD;
//	CREATOR:				Helgevold - Jan Magne Dybvik&#xD;
// REQUIREMENTS: NX CPU&#xD;
//&#xD;
// DESCRTIPTION: 	Leser en SNMP OID via SNMP Get-Request&#xD;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//  VERSION LOG:&#xD;
//	 VERSION			DATE				SIGN						DESCRIPTION&#xD;
//	 1.0					2024-05-15		Jan Magne Dybvik	Initial release&#xD;
//	 1.1					2024-06-11		Jan Magne Dybvik	Lagt til steg 51 og else i Switch case for å unngå heng&#xD;
//  1.1.1				2024-08-02		Jan Magne Dybvik	Lagt til kommentarer&#xD;
//  1.2					2024-09-11		Jan Magne Dybivk	Hold UDP port åpen istedet for å lukke den for hver forespørsel, Sjekk av error i SNMP respons, fikset hardkodet UDP send lengde, Enumeration for definering av tilstand&#xD;
//  1.2.1				2024-09-13		Jan Magne Dybvik	Lagt til debug tags, Flushing UDP Socket av buffer, &#xD;
//  1.2.2				2024-12-04		Jan Magne Dybvik  Lagt til breadcrumb ved valideringsfeil og endret Wrk_RequestID til DINT&#xD;
//  1.2.3				2024-12-09		Jan Magne Dybvik  Reset Wrk_RequestID to 0 on roll over &#xD;
//	 1.2.4				2025-05-20		Jan Magne Dybvik	Clear Buffer on recieve errors&#xD;
//  1.2.5				2025-05-22		Jan Magne Dybvik	Store sent OID internally to enable change of OID at runtime&#xD;
//  1.2.6				2025-06-10		Jan Magne Dybvik	Store expected and recieved IP address and port when mismatched&#xD;
//&#xD;
//================================================================================================================================&#xD;
&#xD;
// Initialize variables&#xD;
Wrk_Create := FALSE;&#xD;
Wrk_Send := FALSE;&#xD;
Wrk_Recv := FALSE;&#xD;
Wrk_Close := FALSE;&#xD;
Wrk_Flush :=FALSE;&#xD;
Wrk_Done := FALSE;&#xD;
Wrk_Error := FALSE;&#xD;
Wrk_Busy := FALSE;&#xD;
ENO :=TRUE;&#xD;
&#xD;
CASE Wrk_State OF&#xD;
	Disabled: // 16#00 Disabled&#xD;
		ENO :=FALSE;&#xD;
		Ext_Telegram.Ready := FALSE;&#xD;
		IF ENI THEN&#xD;
			Wrk_State := CreateSocket;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
	&#xD;
	CloseSocket: // 16#10 Close Socket&#xD;
		Ext_Telegram.Ready := FALSE;&#xD;
		Wrk_Close := TRUE;&#xD;
		Wrk_ErrorCode :=  SHL(DINT_TO_DWORD(EnumToNum(CloseSocket)),16) OR WORD_TO_DWORD(Wrk_CloseSocket.ErrorID);&#xD;
		Wrk_Errors := Wrk_Errors + 1;&#xD;
	&#xD;
		IF Wrk_CloseSocket.Done THEN&#xD;
			Wrk_State := Disabled;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		ELSIF Wrk_CloseSocket.Error THEN&#xD;
			Wrk_State := CloseSocketError;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
		&#xD;
	CloseSocketError: // 16#11&#xD;
		Ext_Telegram.Ready := FALSE;&#xD;
		Wrk_Error := TRUE;&#xD;
		Wrk_ErrorCode :=  SHL(DINT_TO_DWORD(EnumToNum(CloseSocketError)),16) OR WORD_TO_DWORD(Wrk_CloseSocket.ErrorID); &#xD;
		Wrk_Errors := Wrk_Errors + 1;&#xD;
		&#xD;
		IF NOT Ext_Telegram.Execute THEN&#xD;
			Wrk_State := Disabled;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
		&#xD;
		    CreateSocket : // 16#20 Request creating socket.&#xD;
		Wrk_Create := TRUE;&#xD;
		Wrk_Busy := TRUE;&#xD;
		&#xD;
		IF Wrk_CreateUDP_Socket.Done THEN&#xD;
			Wrk_State := IdleState;&#xD;
			Wrk_TimeInState := T#0s;	&#xD;
		ELSIF Wrk_CreateUDP_Socket.Error THEN&#xD;
			Wrk_State := CreateSocketError;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
	&#xD;
	CreateSocketError: // 16#21&#xD;
			Wrk_Error := TRUE;&#xD;
			Wrk_ErrorCode :=  SHL(DINT_TO_DWORD(EnumToNum(CreateSocketError)),16) OR WORD_TO_DWORD(Wrk_CreateUDP_Socket.ErrorID); &#xD;
			Wrk_Errors := Wrk_Errors + 1;&#xD;
			&#xD;
			IF NOT Ext_Telegram.Execute THEN&#xD;
				Wrk_State := CloseSocket;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			END_IF;&#xD;
	&#xD;
	IdleState: // 16#30 Idle&#xD;
		Ext_Telegram.Ready := TRUE;&#xD;
		IF NOT ENI THEN&#xD;
			Wrk_State := CloseSocket;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		ELSIF Ext_Telegram.Execute THEN&#xD;
			Wrk_State := BuildSNMPMessage;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
&#xD;
    BuildSNMPMessage:  // 16#31 Build message&#xD;
		Wrk_RequestID := Wrk_RequestID + 1;&#xD;
		IF Wrk_RequestID &lt; 0 THEN&#xD;
			Wrk_RequestID := 0;&#xD;
		END_IF;&#xD;
		&#xD;
		// Encoding&#xD;
		// SNMP Version&#xD;
		Wrk_SNMP_Version_Len := HE_SNMP_EncodeInteger(&#xD;
			Ext_Buffer := Wrk_SNMP_Version_Buff,&#xD;
			Inp_Value := USINT_TO_DWORD(Ext_Telegram.SNMP_Ver)&#xD;
			);&#xD;
		&#xD;
		// SNMP Community String		&#xD;
		Wrk_Community_Len := HE_SNMP_EncodeString(&#xD;
			Ext_Buffer := Wrk_Community_Buff,&#xD;
			Inp_String := Ext_Telegram.Community&#xD;
			);&#xD;
		&#xD;
		// Request ID&#xD;
		Wrk_RequestID_Len := HE_SNMP_EncodeInteger(&#xD;
			Ext_Buffer := Wrk_RequestID_Buff,&#xD;
			Inp_Value := UDINT_TO_DWORD(Wrk_RequestID)&#xD;
			);&#xD;
		&#xD;
		// Error status&#xD;
		Wrk_ErrorStatus_Len := HE_SNMP_EncodeInteger(&#xD;
			Ext_Buffer := Wrk_ErrorStatus_Buff,&#xD;
			Inp_Value := 0&#xD;
			);&#xD;
		&#xD;
		// Error index&#xD;
		Wrk_ErrorIndex_Len := HE_SNMP_EncodeInteger(&#xD;
			Ext_Buffer := Wrk_ErrorIndex_Buff,&#xD;
			Inp_Value := 0&#xD;
			);&#xD;
		&#xD;
		Wrk_SendOID := Ext_Telegram.OID;&#xD;
		Wrk_OID_Len := HE_SNMP_EncodeOID(&#xD;
			Ext_Buffer := Wrk_OID_Buff,&#xD;
			Inp_OID := Wrk_SendOID&#xD;
		);&#xD;
		&#xD;
		// OID Value&#xD;
		Wrk_OID_Value_Len := HE_SNMP_EncodeNull(Ext_Buffer := Wrk_OID_Value_Buff);&#xD;
		&#xD;
		// Sequence lengths&#xD;
		Wrk_VarBind_Len :=Wrk_OID_Len + Wrk_OID_Value_Len;&#xD;
		Wrk_VarList_Len := Wrk_VarBind_Len + 2;&#xD;
		Wrk_PDU_Length := Wrk_RequestID_Len + Wrk_ErrorStatus_Len + Wrk_ErrorIndex_Len + Wrk_VarList_Len + 2;&#xD;
		Wrk_SNMP_GET_Length := Wrk_SNMP_Version_Len + Wrk_Community_Len + Wrk_PDU_Length + 2;&#xD;
&#xD;
		// Build send buffer&#xD;
		Wrk_SendBufferOffset := 0;&#xD;
		// SNMP message&#xD;
		// Sequence Type	&#xD;
		Wrk_SendBuffer[0] := 16#30;&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
		// Sequence length&#xD;
		Wrk_SendBuffer[1] := UINT_TO_BYTE(Wrk_SNMP_GET_Length);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
&#xD;
		MemCopy(In:=Wrk_SNMP_Version_Buff[0], AryOut:=Wrk_SendBuffer[Wrk_SendBufferOffset], Size:= Wrk_SNMP_Version_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + Wrk_SNMP_Version_Len;&#xD;
&#xD;
		MemCopy(In:=Wrk_Community_Buff[0], AryOut:=Wrk_SendBuffer[Wrk_SendBufferOffset], Size:= Wrk_Community_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + Wrk_Community_Len;&#xD;
		&#xD;
		// SNMP PDU&#xD;
		// GetRequest PDU type&#xD;
		Wrk_SendBuffer[Wrk_SendBufferOffset] := 16#A0;&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
		// GetRequest PDU length&#xD;
		Wrk_SendBuffer[Wrk_SendBufferOffset] := UINT_TO_BYTE(Wrk_PDU_Length);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
&#xD;
		// Request ID&#xD;
		MemCopy(In:=Wrk_RequestID_Buff[0], AryOut:=Wrk_SendBuffer[Wrk_SendBufferOffset], Size:= Wrk_RequestID_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + Wrk_RequestID_Len;&#xD;
&#xD;
		// Error status&#xD;
		MemCopy(In:=Wrk_ErrorStatus_Buff[0], AryOut:=Wrk_SendBuffer[Wrk_SendBufferOffset], Size:= Wrk_ErrorStatus_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + Wrk_ErrorStatus_Len;&#xD;
		&#xD;
		// Error index&#xD;
		MemCopy(In:=Wrk_ErrorIndex_Buff[0], AryOut:=Wrk_SendBuffer[Wrk_SendBufferOffset], Size:= Wrk_ErrorIndex_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + Wrk_ErrorIndex_Len;&#xD;
&#xD;
		// var list&#xD;
		// Sequence Type&#xD;
		Wrk_SendBuffer[Wrk_SendBufferOffset] := 16#30;&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
		// Sequence length&#xD;
		Wrk_SendBuffer[Wrk_SendBufferOffset] := UINT_TO_BYTE(Wrk_VarList_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
		&#xD;
		// Var binding&#xD;
		// Sequence Type&#xD;
		Wrk_SendBuffer[Wrk_SendBufferOffset] := 16#30;&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
		// Sequence length&#xD;
		Wrk_SendBuffer[Wrk_SendBufferOffset] := UINT_TO_BYTE(Wrk_VarBind_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + 1;&#xD;
		&#xD;
		// OID&#xD;
		MemCopy(In:=Wrk_OID_Buff[0], AryOut:=Wrk_SendBuffer[Wrk_SendBufferOffset], Size:= Wrk_OID_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + Wrk_OID_Len;&#xD;
		&#xD;
		// OID Value&#xD;
		MemCopy(In:=Wrk_OID_Value_Buff[0], AryOut:=Wrk_SendBuffer[Wrk_SendBufferOffset], Size:= Wrk_OID_Value_Len);&#xD;
		Wrk_SendBufferOffset := Wrk_SendBufferOffset + Wrk_OID_Value_Len;&#xD;
		&#xD;
		Wrk_State := SendUDP;&#xD;
		Wrk_TimeInState := T#0s;&#xD;
		&#xD;
	SendUDP: // 16#40 Send UDP&#xD;
		Wrk_Busy := TRUE;&#xD;
		Wrk_SendSize := Wrk_SendBufferOffset;&#xD;
		Wrk_Send := TRUE;&#xD;
		&#xD;
        IF (Wrk_SendUDP_Socket.Done) THEN&#xD;
                Wrk_State := RecieveUDP;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
        ELSIF (Wrk_SendUDP_Socket.Error) OR Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
                Wrk_State := SendUDPError;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
        END_IF;&#xD;
		&#xD;
	SendUDPError: // 16#41 Send UDP error&#xD;
		Wrk_Error := TRUE;&#xD;
		Wrk_ErrorCode := SHL(DINT_TO_DWORD(EnumToNum(SendUDPError)),16) OR WORD_TO_DWORD(Wrk_SendUDP_Socket.ErrorID);&#xD;
		Wrk_Errors := Wrk_Errors + 1;&#xD;
		&#xD;
		IF NOT Ext_Telegram.Execute THEN&#xD;
			Wrk_State := CloseSocket;	// Send error not expected under normal operation. Close and Create new Socket&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
		&#xD;
	RecieveUDP:  // 16#50 Request receiving data.&#xD;
		Wrk_Len := SizeOfAry(Wrk_RcvBuffer);&#xD;
		Wrk_Recv := TRUE;&#xD;
		Wrk_Busy := TRUE;&#xD;
&#xD;
        IF (Wrk_RecvUDP_Socket.Done) THEN&#xD;
            Wrk_State := VerifyRecieveSource;  // Normal end&#xD;
			Wrk_TimeInState := T#0s;&#xD;
        ELSIF (Wrk_RecvUDP_Socket.Error) OR Wrk_TimeInState &gt; Cfg_Timeout THEN&#xD;
            Wrk_State:= RecieveUDPError;  // Error end&#xD;
			Wrk_TimeInState := T#0s;&#xD;
        END_IF;&#xD;
		&#xD;
	RecieveUDPError: // 16#51 Recieve error&#xD;
		Wrk_Error := TRUE;&#xD;
		Wrk_ErrorCode := SHL(DINT_TO_DWORD(EnumToNum(RecieveUDPError)),16) OR WORD_TO_DWORD(Wrk_RecvUDP_Socket.ErrorID);&#xD;
		Wrk_Errors := Wrk_Errors + 1;&#xD;
		&#xD;
		IF NOT Ext_Telegram.Execute THEN&#xD;
			Wrk_State := ClearBuffer;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
			&#xD;
	RecieveSNMPErrorResponse: // 16#52 Recived SNMP Error&#xD;
		// Clear output values if invalid&#xD;
			Wrk_RespValue := 0;&#xD;
			Wrk_RespString := '';&#xD;
			&#xD;
			Wrk_Error := TRUE;&#xD;
			Wrk_ErrorCode := SHL(DINT_TO_DWORD(EnumToNum(RecieveSNMPErrorResponse)),16) OR UDINT_TO_DWORD(Wrk_RecvErrorStatus);&#xD;
			Wrk_Errors := Wrk_Errors + 1;&#xD;
			&#xD;
			IF NOT Ext_Telegram.Execute THEN&#xD;
				Wrk_State := IdleState;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			END_IF;&#xD;
		&#xD;
		VerifyRecieveSource: // 16#60 Close Socket and verify source&#xD;
			Wrk_Busy := TRUE;&#xD;
			&#xD;
			Wrk_RcvCorrectIP := FIND(In1:=Ext_Telegram.RemoteIP, In2:=Wrk_RemoteAddress.IpAdr) = 1;&#xD;
			Wrk_RcvCorrectPort := Ext_Telegram.RemotePort = Wrk_RemoteAddress.PortNo;&#xD;
			&#xD;
			IF Wrk_RcvCorrectIP AND Wrk_RcvCorrectPort THEN&#xD;
				Wrk_State := ParseRecievedData;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			ELSE&#xD;
				Wrk_State := VerifyRecieveSourceError;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			END_IF;&#xD;
			&#xD;
		VerifyRecieveSourceError: // 16#61 Verification error&#xD;
			Wrk_Error := TRUE;&#xD;
			Wrk_ErrorCode := SHL(DINT_TO_DWORD(EnumToNum(VerifyRecieveSourceError)),16) OR WORD_TO_DWORD(Wrk_RecvUDP_Socket.ErrorID);&#xD;
			Wrk_Errors := Wrk_Errors + 1;&#xD;
			Wrk_Err_ExpectedIP := Ext_Telegram.RemoteIP;&#xD;
			Wrk_Err_RecievedIP := Wrk_RemoteAddress.IpAdr;&#xD;
			Wrk_Err_ExpectedPort := Ext_Telegram.RemotePort;&#xD;
			Wrk_Err_RecievedPort := Wrk_RemoteAddress.PortNo;&#xD;
			&#xD;
			IF NOT Ext_Telegram.Execute THEN&#xD;
				Wrk_State := ClearBuffer;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			END_IF;&#xD;
			&#xD;
		ParseRecievedData: // 16#70 Parse data&#xD;
			Wrk_Busy := TRUE;&#xD;
			Wrk_ValidData := 0;&#xD;
			Wrk_RecvBufferOffset := 0;&#xD;
			// Check for Sequence&#xD;
			Wrk_Valid := Wrk_RcvBuffer[Wrk_RecvBufferOffset] = 16#30;&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=0, BitVal:=Wrk_Valid);&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			Wrk_SNMP_Sequence_Len := BYTE_TO_UINT(Wrk_RcvBuffer[Wrk_RecvBufferOffset]);&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			&#xD;
			// Decode SNMP Version&#xD;
			Wrk_Valid := HE_SNMP_Decode(&#xD;
				Ext_Buffer := Wrk_RcvBuffer,&#xD;
				Ext_BufferOffset := Wrk_RecvBufferOffset,&#xD;
				Out_Integer =&gt; Wrk_RecvSNMP_Version&#xD;
				);&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=1, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// Decode Community String&#xD;
			Wrk_Valid := HE_SNMP_Decode(&#xD;
				Ext_Buffer := Wrk_RcvBuffer,&#xD;
				Ext_BufferOffset := Wrk_RecvBufferOffset,&#xD;
				Out_String =&gt; Wrk_RecvSNMP_Community&#xD;
				);&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=2, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// Protocol Data Unit length&#xD;
			// Check for GetResponse PDU (16#A2)&#xD;
			Wrk_Valid := Wrk_RcvBuffer[Wrk_RecvBufferOffset] = 16#A2;&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			Wrk_RecvPDU_Len := BYTE_TO_UINT(Wrk_RcvBuffer[Wrk_RecvBufferOffset]);&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=3, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// Decode Request ID&#xD;
			Wrk_Valid := HE_SNMP_Decode(&#xD;
				Ext_Buffer := Wrk_RcvBuffer,&#xD;
				Ext_BufferOffset := Wrk_RecvBufferOffset,&#xD;
				Out_Integer =&gt; Wrk_RecvRequestID&#xD;
				);&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=4, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// Verify Request ID&#xD;
			Wrk_Valid := Wrk_RequestID = Wrk_RecvRequestID;&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=5, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// Decode Error Status (0 = No Error)&#xD;
			Wrk_Valid := HE_SNMP_Decode(&#xD;
				Ext_Buffer := Wrk_RcvBuffer,&#xD;
				Ext_BufferOffset := Wrk_RecvBufferOffset,&#xD;
				Out_Integer =&gt; Wrk_RecvErrorStatus&#xD;
				);&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=6, BitVal:=Wrk_Valid);&#xD;
			// Check for error&#xD;
			Wrk_ErrorResponse := Wrk_RecvErrorStatus &lt;&gt; 0;&#xD;
			&#xD;
			// Decode Error Index (0 = No Error)&#xD;
			Wrk_Valid := HE_SNMP_Decode(&#xD;
				Ext_Buffer := Wrk_RcvBuffer,&#xD;
				Ext_BufferOffset := Wrk_RecvBufferOffset,&#xD;
				Out_Integer =&gt; Wrk_RecvErrorIndex&#xD;
				);&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=7, BitVal:=Wrk_Valid);&#xD;
			// Check for errors&#xD;
			Wrk_ErrorResponse := Wrk_ErrorResponse OR Wrk_RecvErrorIndex &lt;&gt; 0;&#xD;
			&#xD;
			// Check for Sequence / List (16#30)&#xD;
			Wrk_Valid :=Wrk_RcvBuffer[Wrk_RecvBufferOffset] = 16#30;&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=8, BitVal:=Wrk_Valid);&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			Wrk_RecvVarList_Len := BYTE_TO_UINT(Wrk_RcvBuffer[Wrk_RecvBufferOffset]);&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			&#xD;
			// Check for Sequence / List (16#30)&#xD;
			Wrk_Valid := Wrk_RcvBuffer[Wrk_RecvBufferOffset] = 16#30;&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=9, BitVal:=Wrk_Valid);&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			Wrk_RecvVarBind_Len := BYTE_TO_UINT(Wrk_RcvBuffer[Wrk_RecvBufferOffset]);&#xD;
			Wrk_RecvBufferOffset := Wrk_RecvBufferOffset + 1;&#xD;
			&#xD;
			// Decode OID&#xD;
			Wrk_Valid := HE_SNMP_Decode(&#xD;
				Ext_Buffer := Wrk_RcvBuffer,&#xD;
				Ext_BufferOffset := Wrk_RecvBufferOffset,&#xD;
				Out_String =&gt; Wrk_RecvOID&#xD;
				);&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=10, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// Verify OID&#xD;
			Wrk_Valid := FIND(In1:=Wrk_SendOID, In2:=Wrk_RecvOID) = 1;&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=11, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// Decode Response&#xD;
			Wrk_Valid := HE_SNMP_Decode(&#xD;
				Ext_Buffer := Wrk_RcvBuffer,&#xD;
				Ext_BufferOffset := Wrk_RecvBufferOffset,&#xD;
				Out_Integer =&gt; Wrk_RespValue,&#xD;
				Out_String =&gt; Wrk_RespString&#xD;
				);&#xD;
			OutABit(InOut:=Wrk_ValidData, Pos:=12, BitVal:=Wrk_Valid);&#xD;
			&#xD;
			// If all checks pass then success&#xD;
			IF Wrk_ErrorResponse THEN&#xD;
				Wrk_State := RecieveSNMPErrorResponse;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			ELSIF Wrk_ValidData = 16#1FFF THEN&#xD;
				Wrk_State := ParsedDataValid;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
				Wrk_Successes := Wrk_Successes + 1;&#xD;
			ELSE&#xD;
				Wrk_State := ParsedDataInvalid;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			END_IF;&#xD;
	&#xD;
	ParsedDataInvalid: // 16#71 Invalid data&#xD;
			// Clear output values if invalid&#xD;
			Wrk_RespValue := 0;&#xD;
			Wrk_RespString := '';&#xD;
	&#xD;
			Wrk_Error := TRUE;&#xD;
			Wrk_ErrorCode := SHL(DINT_TO_DWORD(EnumToNum(ParsedDataInvalid)),16) OR WORD_TO_DWORD(Wrk_RecvUDP_Socket.ErrorID);&#xD;
			Wrk_ErrorBreadCrumb :=Wrk_ValidData;&#xD;
			Wrk_Errors := Wrk_Errors + 1;&#xD;
			&#xD;
			Dbg_SendBuffer :=Wrk_SendBuffer;&#xD;
			Dbg_RcvBuffer :=Wrk_RcvBuffer;&#xD;
			&#xD;
			IF NOT Ext_Telegram.Execute THEN&#xD;
				Wrk_State := ClearBuffer;&#xD;
				Wrk_TimeInState := T#0s;&#xD;
			END_IF;&#xD;
			&#xD;
	ParsedDataValid: // 16#72 Reset state machine&#xD;
		Wrk_Done := TRUE;&#xD;
		IF NOT Ext_Telegram.Execute THEN&#xD;
			Wrk_State := ClearBuffer;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
		&#xD;
	ClearBuffer: // 16#80&#xD;
		Wrk_Flush :=TRUE;&#xD;
		&#xD;
		IF Wrk_ClearBuffer.Done THEN&#xD;
			Wrk_State := IdleState;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		ELSIF Wrk_ClearBuffer.Error THEN&#xD;
			Wrk_State := IdleState;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		END_IF;&#xD;
	&#xD;
	ClearBuffeError: // 16#81&#xD;
			Wrk_Error := TRUE;&#xD;
			Wrk_ErrorCode := SHL(DINT_TO_DWORD(EnumToNum(ClearBuffeError)),16) OR WORD_TO_DWORD(Wrk_ClearBuffer.ErrorID);&#xD;
			Wrk_Errors := Wrk_Errors + 1;&#xD;
			&#xD;
			Wrk_State := IdleState;&#xD;
			Wrk_TimeInState := T#0s;&#xD;
		&#xD;
ELSE&#xD;
	// Udefinert tilstand&#xD;
	Wrk_Error := TRUE;	&#xD;
	Wrk_ErrorCode := 16#FFFF0000;&#xD;
	Wrk_Errors := Wrk_Errors + 1;&#xD;
	&#xD;
	Wrk_State := CloseSocket;&#xD;
	Wrk_TimeInState := T#0s;&#xD;
				&#xD;
END_CASE;&#xD;
&#xD;
 // Get Interval Time&#xD;
 Wrk_TaskIntervalTime := GetMyTaskInterval();&#xD;
 // Increment state time&#xD;
 Wrk_TimeInState :=  ADD_TIME(In1:=Wrk_TimeInState, In2:=Wrk_TaskIntervalTime);&#xD;
&#xD;
// Create socket&#xD;
Wrk_CreateUDP_Socket(&#xD;
    Execute   :=Wrk_Create,&#xD;
    SrcUdpPort:=Cfg_LocalPort, // Local UDP port number&#xD;
    Socket    =&gt; Wrk_Socket&#xD;
);&#xD;
&#xD;
// Request sending data&#xD;
Wrk_Socket.DstAdr.PortNo:= Ext_Telegram.RemotePort;&#xD;
Wrk_Socket.DstAdr.IpAdr := Ext_Telegram.RemoteIP;&#xD;
Wrk_SendUDP_Socket(&#xD;
    Execute:=Wrk_Send,&#xD;
    Socket :=Wrk_Socket, // Socket&#xD;
    SendDat:=Wrk_SendBuffer[0], // Send data&#xD;
    Size   :=Wrk_SendSize&#xD;
); // Send data size&#xD;
&#xD;
Wrk_RecvUDP_Socket(&#xD;
    Execute:=Wrk_Recv,&#xD;
    Socket :=Wrk_Socket, // Socket&#xD;
    TimeOut:=Ext_Telegram.Timeout,  // Timeout time&#xD;
    Size := Wrk_Len, // Receive data size&#xD;
    RcvDat :=Wrk_RcvBuffer[0],  // Receive data buffer&#xD;
	SendNodeAdr =&gt; Wrk_RemoteAddress&#xD;
); // Receive address&#xD;
	&#xD;
// Close socket&#xD;
Wrk_CloseSocket(&#xD;
	Execute:=Wrk_Close,&#xD;
    Socket :=Wrk_Socket&#xD;
);&#xD;
&#xD;
// Clear Buffer&#xD;
Wrk_ClearBuffer(&#xD;
	Execute:=Wrk_Flush, &#xD;
	Socket:=Wrk_Socket&#xD;
);&#xD;
&#xD;
Ext_Telegram.Done := Wrk_Done;&#xD;
Ext_Telegram.Busy := Wrk_Busy;&#xD;
Ext_Telegram.Error := Wrk_Error;&#xD;
Ext_Telegram.ErrorCode := Wrk_ErrorCode;&#xD;
Ext_Telegram.ResponseValue := Wrk_RespValue;&#xD;
Ext_Telegram.ResponseString := Wrk_RespString;&#xD;
&#xD;
ENO := Wrk_Done OR Wrk_Error;</Text></StructuredTextModel>