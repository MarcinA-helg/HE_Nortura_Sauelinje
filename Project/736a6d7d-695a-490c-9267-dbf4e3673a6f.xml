<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//	NAME:					HE_ATV320_RuntimeData&#xD;
//	CREATOR:				Helgevold - Jan Magne Dybvik&#xD;
// REQUIREMENTS: NX CPU&#xD;
//&#xD;
// DESCRTIPTION: 	Leser ut Energiforbruk, Driftstid og På tid via Ethernet/IP Explicit Message&#xD;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//  VERSION LOG:&#xD;
//	 VERSION			DATE				SIGN						DESCRIPTION&#xD;
//	 1.0					2023-10-26		Jan Magne Dybvik	Initial release&#xD;
//	 1.1					2023-11-01		Jan Magne Dybvik	Endret IP adresse til RoutePath, bug fix&#xD;
//  2.0					2023-11-27		Jan Magne Dybvik	Lagt til avlsening av Frekvensomformer tilstand/modus&#xD;
//  2.1					2023-12-18		Jan Magne Dybvik	Lagt til avlesning av Motorstrøm, og sørget for at sekvensen avbrytes ved første feil for å korte ned ventetiden.&#xD;
//  2.1.1				2023-12-20		Jan Magne Dybvik	Energimåling pr. dag. Driftstid og Påtid i dager&#xD;
//	 2.1.2				2024-09-27		Ruben Byman			Endret .Intern.Status_Servicebryter til .Intern.GeneralMessage&#xD;
//&#xD;
//================================================================================================================================&#xD;
&#xD;
(*&#xD;
	Funkjonsblokken bentytter seg av CIPUCMMSend instuksjonen. Den er felles for alle instansene av denne funksjonsblokken.&#xD;
	Kun en instans får bruke CIPUCMMSend av gangen. Det bestemmes av Ext_TokenID og Ext_Telegram.Token.&#xD;
	Ext_TokenID blir inkrementert i hver instans slik at alle har unikt nummer.&#xD;
	Når en instans har matchende verdi kan den benytte seg av CIPUCMMSend.&#xD;
	Når instansen er ferdig inkrementeres  Ext_Telegram.Token slik at neste instans får bruke CIPUCMMSend.&#xD;
	Etter siste instans blir Ext_TokenID og Ext_Telegram.Token igjen sammenlignet og hvis de er like har alle instanser kjørt og Ext_Telegram.Token resettes.&#xD;
	&#xD;
	Routing: Når en benytter Ethernet/IP interface integrert i CPU er det ikke behov for routing da vil Cfg_RoutePath være '02\[IP ADDR]'		(f.eks: '02\10.128.218.11')&#xD;
	Når en benytter en add-on modul må en konfigurere Routing. Da vil Cfg_RoutePath være '[Backplane]\#[([X Bus Unit No.]*10) + ([Port No.]-1)]\02\[IP ADDR]'		(f.eks: '01\#10\02\10.128.118.11') for å gå via Add-on modul 1 port 1&#xD;
&#xD;
Eksempel Program:&#xD;
&#xD;
VAR&#xD;
&#xD;
		CIPUCMMSend_Instance : CIPUCMMSend;&#xD;
		Drive_1 : HE_ATV320_RuntimeData;&#xD;
		Drive_2 : HE_ATV320_RuntimeData;&#xD;
		Telegram : STRUCT_ExplicitMessageTelegram;&#xD;
		TokenID : UINT;&#xD;
		Timeout : UINT;&#xD;
		EnergyConsumption : UDINT;&#xD;
		PowerOnTime : UDINT;&#xD;
		RunTime : UDINT;&#xD;
&#xD;
END_VAR&#xD;
&#xD;
// PeriodicTask0&#xD;
&#xD;
CIPUCMMSend_Instance(&#xD;
	Execute:= Telegram.Execute, &#xD;
	RoutePath:= Telegram.RoutePath, &#xD;
	TimeOut:= Telegram.TimeOut, &#xD;
	ServiceCode:= Telegram.ServiceCode, &#xD;
	RqPath:= Telegram.ReqPath, &#xD;
	ServiceDat:= Telegram.ServiceData, &#xD;
	Size:= Telegram.Size, &#xD;
	RespServiceDat:= Telegram.RespServiceData, &#xD;
	Done=&gt;Telegram.Done, &#xD;
	Busy=&gt;Telegram.Busy,&#xD;
	Error=&gt; Telegram.Error, &#xD;
	ErrorID=&gt; Telegram.ErrorID, &#xD;
	ErrorIDEx=&gt; Telegram.ErrorIDEx, &#xD;
	RespSize=&gt;Telegram.RespSize&#xD;
);&#xD;
&#xD;
TokenID := 0;&#xD;
Timeout := 20; // 2 sek&#xD;
&#xD;
Drive_1(&#xD;
	FrekvOmf := FrekvOmf[1],&#xD;
	Ext_Telegram := Telegram,&#xD;
	Ext_TokenID := TokenID,&#xD;
	Cfg_RoutePath := '02\10.128.218.11',&#xD;
	Cfg_Timeout := Timeout,&#xD;
	Val_APH =&gt; Drive_1_EnergyConsumption,&#xD;
	Val_PTH =&gt; Drive_1_PowerOnTime,&#xD;
	Val_RTH =&gt; Drive_1_RunTime&#xD;
);&#xD;
&#xD;
Drive_2(&#xD;
	FrekvOmf := FrekvOmf[2],&#xD;
	Ext_Telegram := Telegram,&#xD;
	Ext_TokenID := TokenID,&#xD;
	Cfg_RoutePath := '02\10.128.218.12',&#xD;
	Cfg_Timeout := Timeout,&#xD;
	Val_APH =&gt; Drive_2_EnergyConsumption,&#xD;
	Val_PTH =&gt; Drive_2_PowerOnTime,&#xD;
	Val_RTH =&gt; Drive_2_RunTime&#xD;
);&#xD;
&#xD;
IF Telegram.Token &gt;= TokenID THEN&#xD;
	Telegram.Token := 0;&#xD;
END_IF;&#xD;
&#xD;
*)&#xD;
&#xD;
//================================================================================================================================&#xD;
&#xD;
&#xD;
CASE Wrk_State OF&#xD;
	0: // Wait for turn&#xD;
		IF Ext_Telegram.Token = Ext_TokenID THEN&#xD;
			Wrk_State := 10;&#xD;
		END_IF;&#xD;
			&#xD;
	10: // Start Read APH (Energy Consumption)&#xD;
		// Configure CIPUCMMSend instruction&#xD;
		Ext_Telegram.RoutePath := Cfg_RoutePath;&#xD;
		&#xD;
		Ext_Telegram.ServiceCode :=16#0E;&#xD;
		Ext_Telegram.Size :=0;&#xD;
		Ext_Telegram.TimeOut :=Cfg_Timeout;&#xD;
&#xD;
		Ext_Telegram.ReqPath.ClassID := 16#71;&#xD;
		Ext_Telegram.ReqPath.InstanceID :=1;&#xD;
		Ext_Telegram.ReqPath.isAttributeID := TRUE;&#xD;
		Ext_Telegram.ReqPath.AttributeID := 16#1F;&#xD;
		&#xD;
		Ext_Telegram.Execute := TRUE;&#xD;
&#xD;
		Wrk_State := 11;&#xD;
	&#xD;
	11: // Wait for completion&#xD;
		Ext_Telegram.Execute := FALSE;&#xD;
		&#xD;
		IF Ext_Telegram.Done THEN&#xD;
			Wrk_APH_Raw := WORD_TO_UINT(Ext_Telegram.RespServiceData);&#xD;
			Wrk_APH_Valid := TRUE;&#xD;
			Wrk_APH_Success := Wrk_APH_Success + 1;&#xD;
			Wrk_APH_RespSize := Ext_Telegram.RespSize;&#xD;
			Wrk_State := 20;&#xD;
		ELSIF Ext_Telegram.Error THEN&#xD;
			Wrk_APH_Valid := FALSE;&#xD;
			Wrk_APH_ErrorID := Ext_Telegram.ErrorID;&#xD;
			Wrk_APH_Failure := Wrk_APH_Failure + 1;&#xD;
			Wrk_State := 1001;&#xD;
		ELSIF NOT Ext_Telegram.Busy THEN&#xD;
			Wrk_State := 1001;&#xD;
		END_IF;&#xD;
	&#xD;
	20: // Start Read RTH (Motor run time)&#xD;
&#xD;
		Ext_Telegram.ReqPath.AttributeID := 16#20;&#xD;
		&#xD;
		Ext_Telegram.Execute := TRUE;&#xD;
&#xD;
		Wrk_State := 21;&#xD;
	&#xD;
	21: // Wait for completion&#xD;
		Ext_Telegram.Execute := FALSE;&#xD;
		&#xD;
		IF Ext_Telegram.Done THEN&#xD;
			Wrk_RTH_Raw := WORD_TO_UINT(Ext_Telegram.RespServiceData);&#xD;
			Wrk_RTH_Valid := TRUE;&#xD;
			Wrk_RTH_Success := Wrk_RTH_Success + 1;&#xD;
			Wrk_RTH_RespSize := Ext_Telegram.RespSize;&#xD;
			Wrk_State := 30;&#xD;
		ELSIF Ext_Telegram.Error THEN&#xD;
			Wrk_RTH_Valid := FALSE;&#xD;
			Wrk_RTH_ErrorID := Ext_Telegram.ErrorID;&#xD;
			Wrk_RTH_Failure := Wrk_RTH_Failure + 1;&#xD;
			Wrk_State := 1001;&#xD;
		ELSIF NOT Ext_Telegram.Busy THEN&#xD;
			Wrk_State := 1001;&#xD;
		END_IF;&#xD;
		&#xD;
	30: // Start Read PTH (Power on time)&#xD;
&#xD;
		Ext_Telegram.ReqPath.AttributeID := 16#22;&#xD;
		&#xD;
		Ext_Telegram.Execute := TRUE;&#xD;
&#xD;
		Wrk_State := 31;&#xD;
	&#xD;
	31: // Wait for completion&#xD;
		Ext_Telegram.Execute := FALSE;&#xD;
		&#xD;
		IF Ext_Telegram.Done THEN&#xD;
			Wrk_PTH_Raw := WORD_TO_UINT(Ext_Telegram.RespServiceData);&#xD;
			Wrk_PTH_Valid := TRUE;&#xD;
			Wrk_PTH_Success := Wrk_PTH_Success + 1;&#xD;
			Wrk_PTH_RespSize := Ext_Telegram.RespSize;&#xD;
			Wrk_State := 40;&#xD;
		ELSIF Ext_Telegram.Error THEN&#xD;
			Wrk_PTH_Valid := FALSE;&#xD;
			Wrk_PTH_ErrorID := Ext_Telegram.ErrorID;&#xD;
			Wrk_PTH_Failure := Wrk_PTH_Failure + 1;&#xD;
			Wrk_State := 1001;&#xD;
		ELSIF NOT Ext_Telegram.Busy THEN&#xD;
			Wrk_State := 1001;&#xD;
		END_IF;&#xD;
		&#xD;
	40: // Start Read UNT (Units for APH, RTH and PTH)&#xD;
&#xD;
		Ext_Telegram.ReqPath.AttributeID := 16#23;&#xD;
		&#xD;
		Ext_Telegram.Execute := TRUE;&#xD;
&#xD;
		Wrk_State := 41;&#xD;
	&#xD;
	41: // Wait for completion&#xD;
		Ext_Telegram.Execute := FALSE;&#xD;
		&#xD;
		IF Ext_Telegram.Done THEN&#xD;
			Wrk_UNT := Ext_Telegram.RespServiceData;&#xD;
			Wrk_UNT_Valid := TRUE;&#xD;
			Wrk_UNT_Success := Wrk_UNT_Success + 1;&#xD;
			Wrk_UNT_RespSize := Ext_Telegram.RespSize;&#xD;
			Wrk_State := 50;&#xD;
		ELSIF Ext_Telegram.Error THEN&#xD;
			Wrk_UNT_Valid := FALSE;&#xD;
			Wrk_UNT_ErrorID := Ext_Telegram.ErrorID;&#xD;
			Wrk_UNT_Failure := Wrk_UNT_Failure + 1;&#xD;
			Wrk_State := 1001;&#xD;
		ELSIF NOT Ext_Telegram.Busy THEN&#xD;
			Wrk_State := 1001;&#xD;
		END_IF;&#xD;
		&#xD;
	50: // Start Read HMIS (Drive State)&#xD;
&#xD;
		Ext_Telegram.ReqPath.AttributeID := 16#29;&#xD;
		&#xD;
		Ext_Telegram.Execute := TRUE;&#xD;
&#xD;
		Wrk_State := 51;&#xD;
	&#xD;
	51: // Wait for completion&#xD;
		Ext_Telegram.Execute := FALSE;&#xD;
		&#xD;
		IF Ext_Telegram.Done THEN&#xD;
			Wrk_HMIS_Raw := Ext_Telegram.RespServiceData;&#xD;
			Wrk_HMIS_Valid := TRUE;&#xD;
			Wrk_HMIS_Success := Wrk_UNT_Success + 1;&#xD;
			Wrk_HMIS_RespSize := Ext_Telegram.RespSize;&#xD;
			Wrk_State := 60;&#xD;
		ELSIF Ext_Telegram.Error THEN&#xD;
			Wrk_HMIS_Valid := FALSE;&#xD;
			Wrk_HMIS_ErrorID := Ext_Telegram.ErrorID;&#xD;
			Wrk_HMIS_Failure := Wrk_UNT_Failure + 1;&#xD;
			Wrk_State := 1001;&#xD;
		ELSIF NOT Ext_Telegram.Busy THEN&#xD;
			Wrk_State := 1001;&#xD;
		END_IF;&#xD;
		&#xD;
	60: // Start Read LCR (Motor Current)&#xD;
&#xD;
		Ext_Telegram.ReqPath.AttributeID := 16#5;&#xD;
		&#xD;
		Ext_Telegram.Execute := TRUE;&#xD;
&#xD;
		Wrk_State := 61;&#xD;
	&#xD;
	61: // Wait for completion&#xD;
		Ext_Telegram.Execute := FALSE;&#xD;
		&#xD;
		IF Ext_Telegram.Done THEN&#xD;
			Wrk_LCR_Raw := Ext_Telegram.RespServiceData;&#xD;
			Wrk_LCR_Valid := TRUE;&#xD;
			Wrk_LCR_Success := Wrk_LCR_Success + 1;&#xD;
			Wrk_LCR_RespSize := Ext_Telegram.RespSize;&#xD;
			Wrk_State := 1000;&#xD;
		ELSIF Ext_Telegram.Error THEN&#xD;
			Wrk_LCR_Valid := FALSE;&#xD;
			Wrk_LCR_ErrorID := Ext_Telegram.ErrorID;&#xD;
			Wrk_LCR_Failure := Wrk_LCR_Failure + 1;&#xD;
			Wrk_State := 1001;&#xD;
		ELSIF NOT Ext_Telegram.Busy THEN&#xD;
			Wrk_State := 1001;&#xD;
		END_IF;&#xD;
		&#xD;
	1000:	&#xD;
		IF Wrk_UNT_Valid AND Wrk_UNT_RespSize = 2 THEN&#xD;
			Wrk_APH_Unit := Wrk_UNT &amp; WORD#16#3; // Mask of APH unit bits&#xD;
			Wrk_PTH_Unit := SHR(Wrk_UNT, 2) &amp; WORD#16#3; // Shift of PTH bits to first two bits, and mask of bits&#xD;
			Wrk_RTH_Unit := SHR(Wrk_UNT, 4) &amp; WORD#16#3; // Shift of RTH bits to first two bits, and mask of bits&#xD;
			&#xD;
			IF Wrk_APH_Valid AND Wrk_APH_RespSize = 2 THEN&#xD;
					Wrk_APH := Wrk_APH_Raw; // kWh&#xD;
			ELSE&#xD;
					Wrk_APH :=0;&#xD;
			END_IF;&#xD;
			&#xD;
			IF Wrk_PTH_Valid AND Wrk_PTH_RespSize = 2 THEN&#xD;
					Wrk_PTH := Wrk_PTH_Raw * 3600; // Hours&#xD;
			ELSE&#xD;
					Wrk_PTH := 0;&#xD;
			END_IF;&#xD;
					&#xD;
			IF Wrk_RTH_Valid AND Wrk_RTH_RespSize = 2 THEN&#xD;
					Wrk_RTH := Wrk_RTH_Raw * 3600; // Hours&#xD;
			ELSE&#xD;
					Wrk_RTH :=0;&#xD;
			END_IF;&#xD;
			&#xD;
		END_IF;&#xD;
		&#xD;
		IF Wrk_HMIS_Valid AND Wrk_HMIS_RespSize = 2 THEN&#xD;
			Wrk_HMIS := Wrk_HMIS_Raw;&#xD;
		END_IF;&#xD;
		&#xD;
		IF Wrk_LCR_Valid AND Wrk_LCR_RespSize = 2 THEN &#xD;
			WRK_LCR := INT_TO_REAL(WORD_TO_INT(Wrk_LCR_Raw)) / 10.0;&#xD;
		END_IF;&#xD;
		 &#xD;
		Ext_Telegram.Token := Ext_Telegram.Token + 1;&#xD;
		Wrk_State := 0;&#xD;
	&#xD;
	// General error&#xD;
	1001:&#xD;
		Ext_Telegram.Token := Ext_Telegram.Token + 1;&#xD;
		Wrk_State := 0;&#xD;
&#xD;
END_CASE;&#xD;
&#xD;
// Update Outputs&#xD;
Val_APH := Wrk_APH;&#xD;
Val_PTH := Wrk_PTH;&#xD;
Val_RTH := Wrk_RTH;&#xD;
Val_HMIS := WORD_TO_UINT(Wrk_HMIS);&#xD;
Val_LCR := WRK_LCR;&#xD;
&#xD;
// Sjekker om det er en ny dag&#xD;
DtToDateStruct(In:=GetTime(), DateStruct=&gt;Wrk_DT_Struct);&#xD;
&#xD;
IF Wrk_Today &lt;&gt; Wrk_DT_Struct.Day THEN&#xD;
	Wrk_Today := Wrk_DT_Struct.Day;&#xD;
	Wrk_APH_Capture := Wrk_APH;&#xD;
END_IF;&#xD;
&#xD;
IF Wrk_APH_Capture &gt; Wrk_APH THEN&#xD;
	Wrk_APH_Capture := Wrk_APH;&#xD;
END_IF;&#xD;
&#xD;
// Energiforbruk i dag&#xD;
FrekvOmf.EXT_Statistics.EnergyConsumption_Today:= UDINT_TO_REAL(Wrk_APH - Wrk_APH_Capture) / 1000.0;&#xD;
&#xD;
&#xD;
FrekvOmf.EXT_Statistics.Current := WRK_LCR;&#xD;
FrekvOmf.EXT_Statistics.Runtime_VFD := Wrk_RTH / 86400;&#xD;
FrekvOmf.EXT_Statistics.Ontime_VFD := Wrk_PTH / 86400;&#xD;
IF Wrk_HMIS = 3 THEN&#xD;
	FrekvOmf.EXT_Operator.Actual_State := '3 - NST - Servicebryter';&#xD;
ELSE&#xD;
	FrekvOmf.EXT_Operator.Actual_State := HE_ATV_Drive_State(Inp_HMIS := Wrk_HMIS,  Cfg_Delimiter := ' - ', Cfg_Composition := 7);&#xD;
END_IF;&#xD;
&#xD;
// Inkrement TokenID for next instance&#xD;
Ext_TokenID := Ext_TokenID + 1;</Text></StructuredTextModel>