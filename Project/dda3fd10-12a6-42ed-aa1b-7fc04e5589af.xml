<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//	NAME:			RegVentil&#xD;
//	CREATOR:		Helgevold - Daniel Årvik&#xD;
// &#xD;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//  VERSION LOG:&#xD;
//	VERSION			DATE					SIGN							DESCRIPTION&#xD;
//	1.0.0					2023-10-06			Daniel Årvik					Initial release&#xD;
//	2.0.0					2025-04-15			William Veim				ReWork&#xD;
//	2.0.1					2025-04-23			Ruben Byman				Various fixes: mixing of raw values and %-values, missing link in output, naming/translations, Interlock state locked to predefined&#xD;
//	2.0.2					2025-04-29			Ruben Byman				Added alarm&#xD;
//	3.0.0					2025-07-07			William Veim				Configuration of input and output (X0, X1, Y0, Y1) retrived from function (input type of Ain/Aout module type) &#xD;
//&#xD;
//================================================================================================================================&#xD;
//&#xD;
//		FUNCTIONALITY:&#xD;
//		*	Operasjonsmodus:&#xD;
//			-	OFF				Output Variable = Y0/Y1&#xD;
//			-	MANUAL	Output Variable manual control from SCADA&#xD;
//			-	AUTO			Input Variable copied to output scaled with Min/max&#xD;
//		*	Feedback to SCADA&#xD;
//		*	Fault (With delay) if the difference between opening and feedback too large.&#xD;
//		*	Fault when cable break is present (Feedback = 7FFF/32767). Feedback is set to 999&#xD;
//		*	Fault when feedback is not within range. Feedback is set to 999&#xD;
//		*	Interlock is controlled by state control, will go to predefined output, default 0%&#xD;
//&#xD;
//===============================================================================================================================&#xD;
&#xD;
(*************************************************************************&#xD;
 *	INITIAL/SYSTEM VARIABELS&#xD;
 *************************************************************************)&#xD;
Wrk_CurrentTime := 					TruncTod(DT_TO_TOD(In:=GetTime()), _SEC);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	MODE CONTROL&#xD;
 *************************************************************************)&#xD;
&#xD;
IF NOT Inp_Interlock THEN&#xD;
	CASE Ext_AnalogControl.EXT_Operator.Mode OF&#xD;
		&#xD;
	    0://OFF&#xD;
				Wrk_Output := 0;&#xD;
				&#xD;
		1://MAN&#xD;
				Wrk_Output := Ext_AnalogControl.EXT_Operator.Manual_Output;&#xD;
				&#xD;
		2://AUTO&#xD;
				Wrk_Output := ScaleTrans(SclIn	:=Inp_Auto_Gain,&#xD;
																					X0 := 0.0, &#xD;
																					Y0 := Ext_AnalogControl.EXT_Engineering.Auto_MinOutput,&#xD;
																					X1 := 100.0, &#xD;
																					Y1 := Ext_AnalogControl.EXT_Engineering.Auto_MaxOutput);&#xD;
		3://TIMER&#xD;
						//Start control (based on time of day)&#xD;
						RE_TimerStart(Clk:=Wrk_CurrentTime = HE_INT2TOD(Hour:=Ext_AnalogControl.EXT_Engineering.Timer_StartTime_Hour, Minute:=Ext_AnalogControl.EXT_Engineering.Timer_StartTime_Minute));&#xD;
						&#xD;
						IF RE_TimerStart.Q THEN&#xD;
							Wrk_Output := Ext_AnalogControl.EXT_Engineering.Timer_Output;&#xD;
						ELSIF Wrk_TOD_TimedRun.Q THEN&#xD;
							Wrk_Output := 0.0;&#xD;
						END_IF;&#xD;
&#xD;
	END_CASE;&#xD;
END_IF;&#xD;
&#xD;
Wrk_TOD_TimedRun(In:=Ext_AnalogControl.EXT_Operator.Mode=3, PT:=SecToTime(Ext_AnalogControl.EXT_Engineering.Timer_RunTime)); //Running time in timer mode&#xD;
&#xD;
(*************************************************************************&#xD;
 *	OUTPUT CONTROL (Ramping and deadband)&#xD;
 *************************************************************************)&#xD;
&#xD;
 //Looking for change in min or max output &#xD;
IF Wrk_MinOutputSample &lt;&gt; Ext_AnalogControl.EXT_Engineering.Auto_MinOutput THEN&#xD;
	Wrk_MinOrMax_Adjusted:=TRUE;&#xD;
ELSIF Wrk_MaxOutputSample &lt;&gt; Ext_AnalogControl.EXT_Engineering.Auto_MaxOutput THEN&#xD;
	Wrk_MinOrMax_Adjusted:=TRUE;&#xD;
END_IF;&#xD;
Wrk_MinOutputSample:=Ext_AnalogControl.EXT_Engineering.Auto_MinOutput;&#xD;
Wrk_MaxOutputSample:=Ext_AnalogControl.EXT_Engineering.Auto_MaxOutput;&#xD;
&#xD;
//Timer before output bypasses ramping&#xD;
TON_AutoMinMaxAdj(In:=Wrk_MinOrMax_Adjusted, PT:=SecToTime(Ext_AnalogControl.EXT_Engineering.RampTime_AdjMinMax));&#xD;
TON_AutoEng(In:=(Ext_AnalogControl.EXT_Operator.Mode=2 AND NOT Inp_Interlock), PT:=Wrk_RampTime);&#xD;
&#xD;
IF Ext_AnalogControl.EXT_Operator.Mode= 2 THEN&#xD;
	Wrk_RampTime :=SecToTime(Ext_AnalogControl.EXT_Engineering.RampTime_EngAuto);&#xD;
ELSIF Wrk_MinOrMax_Adjusted THEN&#xD;
	Wrk_RampTime := SecToTime(Ext_AnalogControl.EXT_Engineering.RampTime_AdjMinMax);&#xD;
ELSE&#xD;
	Wrk_RampTime:=TIME#0s;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
//When activating AUTO mode or interlock normalizes in AUTO mode, output is ramped from previous output to AUTO output&#xD;
RampGain(ENS:=TRUE, &#xD;
					Inp_Value:=Wrk_Output, &#xD;
					Cfg_StrokeTime:=Wrk_RampTime, &#xD;
					Cfg_Output_X0:=Ext_AnalogControl.EXT_Engineering.Auto_MinOutput, &#xD;
					Cfg_Output_X1:=Ext_AnalogControl.EXT_Engineering.Auto_MaxOutput, &#xD;
					Cfg_Resolution:=FALSE);&#xD;
&#xD;
//Get output variable based on operation mode after ramping/bypass of ramping&#xD;
IF TON_AutoEng.Q OR TON_AutoMinMaxAdj.Q OR Ext_AnalogControl.EXT_Operator.Mode &lt;&gt; 2 THEN&#xD;
	Wrk_OutputRamped:=Wrk_Output;//Ramping bypassed&#xD;
ELSE&#xD;
	Wrk_OutputRamped:=RampGain.Out_Output;//Output from ramping&#xD;
END_IF;&#xD;
&#xD;
//Deadband to reduce minimal output changes&#xD;
Deadband(ENS:=TRUE, &#xD;
					InputValue:=Wrk_OutputRamped, &#xD;
					PercentValue:=Ext_AnalogControl.EXT_Engineering.Deadband, &#xD;
					MinValue:=0, &#xD;
					MaxValue:=100);&#xD;
&#xD;
Wrk_OutputDeadband := Deadband.OutputValue;&#xD;
LIMIT(MN:=Ext_AnalogControl.EXT_Engineering.Auto_MinOutput, &#xD;
			In:=Wrk_OutputDeadband, &#xD;
			MX:=Ext_AnalogControl.EXT_Engineering.Auto_MaxOutput);&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	FAULT CONTROL&#xD;
 *************************************************************************)&#xD;
&#xD;
//Fault based on deviation between feedback and output&#xD;
AnalogFault(ENS:=TRUE, &#xD;
					Reset:=FALSE, &#xD;
					Output:=Ext_AnalogControl.EXT_Operator.Actual_Output, &#xD;
					Feedback:=Ext_AnalogControl.EXT_Operator.Feedback, &#xD;
					MaxValue:=100, &#xD;
					AllowedDeviation:=Ext_AnalogControl.EXT_Engineering.StateCfg_AllowedDeviation, &#xD;
					Delay:= SecToTime(Ext_AnalogControl.EXT_Engineering.StateCfg_DeviationDelay));&#xD;
&#xD;
Wrk_DeviationFault:= 				AnalogFault.Fault;&#xD;
Wrk_ModuleFault:=					Inp_ModuleFault;&#xD;
Wrk_Interlock:=						Inp_Interlock;&#xD;
Wrk_LoopBreak:=					Inp_Feedback = Wrk_InpRawValue_LoopBreak;&#xD;
&#xD;
(*************************************************************************&#xD;
 *	STATE CONTROL&#xD;
 *************************************************************************)&#xD;
&#xD;
//Resets variables before state control&#xD;
Ext_AnalogControl.EXT_General.Sts_Quality := 0;&#xD;
Wrk_ValueState:=0;&#xD;
Wrk_AlarmState:=FALSE;&#xD;
Wrk_AlarmSuffix:='';&#xD;
&#xD;
&#xD;
//Deviation fault&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_1.Sts_State := Wrk_DeviationFault;&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_1.Sts_Desc := 'Deviation fault';&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogControl.EXT_Engineering.StateCfg_1, &#xD;
							Sts_Quality:=Ext_AnalogControl.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
&#xD;
//Feedback fault&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_2.Sts_State := Wrk_LoopBreak;&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_2.Sts_Desc := 'Feedback fault';&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogControl.EXT_Engineering.StateCfg_2, &#xD;
							Sts_Quality:=Ext_AnalogControl.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
&#xD;
//Module fault&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_3.Sts_State := Wrk_ModuleFault;&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_3.Sts_Desc := 'Module fault';&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogControl.EXT_Engineering.StateCfg_3, &#xD;
							Sts_Quality:=Ext_AnalogControl.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
&#xD;
//Interlock&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_4.Sts_State := Wrk_Interlock;&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_4.Sts_Desc := 'Interlock';&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_4.Cfg_Action := 2;	//Locks Interlock to go to predefined output&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogControl.EXT_Engineering.StateCfg_4, &#xD;
							Sts_Quality:=Ext_AnalogControl.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
&#xD;
Ext_AnalogControl.EXT_Engineering.StateCfg_4.Sts_Visible:=Cfg_Interlock_InUse; //Vises bare dersom interlock er i bruk&#xD;
		&#xD;
CASE Wrk_ValueState OF&#xD;
	&#xD;
	0://Continue operation&#xD;
	Wrk_OutputOut:= Wrk_OutputDeadband;&#xD;
	&#xD;
	1://Freeze output&#xD;
	Wrk_OutputOut:=Wrk_OutputOut;&#xD;
	&#xD;
	2://Predefined output&#xD;
	Wrk_OutputOut:=Ext_AnalogControl.EXT_Engineering.StateCfg_PreDefinedOutput;&#xD;
	&#xD;
END_CASE;				&#xD;
&#xD;
(*************************************************************************&#xD;
 *	ALARM CONTROL&#xD;
 *************************************************************************)&#xD;
&#xD;
//Suppress state&#xD;
Ext_AnalogControl.EXT_Alarm.EXT_Engineering.Sts_Suppressed := Inp_AlmSuppress OR (Cfg_AlmSuppress_IfOff AND Ext_AnalogControl.EXT_Operator.Mode = 0);&#xD;
IF Inp_AlmSuppress THEN&#xD;
	Ext_AnalogControl.EXT_Alarm.EXT_Engineering.Sts_SuppressedDesc := Inp_AlmSuppressDesc;&#xD;
ELSIF Cfg_AlmSuppress_IfOff AND Ext_AnalogControl.EXT_Operator.Mode = 0 THEN&#xD;
	Ext_AnalogControl.EXT_Alarm.EXT_Engineering.Sts_SuppressedDesc := 'Off mode';&#xD;
ELSE&#xD;
	Ext_AnalogControl.EXT_Alarm.EXT_Engineering.Sts_SuppressedDesc := '';&#xD;
END_IF;&#xD;
&#xD;
Wrk_AlarmGeneral.Inp_Connected_Cabinet:=				Cfg_ControlCabinet;&#xD;
Wrk_AlarmGeneral.Inp_Connected_Controller:=				Cfg_ControllerTAG;&#xD;
Wrk_AlarmGeneral.Inp_Process_Desc:=							Ext_AnalogControl.EXT_General.Process_Desc;&#xD;
Wrk_AlarmGeneral.Inp_Process_Suffix:=							Wrk_AlarmSuffix;&#xD;
Wrk_AlarmGeneral.Inp_Process_TAG:=							Cfg_ProcessTAG;&#xD;
Wrk_AlarmGeneral.Inp_Process_Value:=							'';&#xD;
Wrk_AlarmGeneral.Inp_Trigger:=										Wrk_AlarmState;&#xD;
&#xD;
Wrk_AlarmGeneral(ENS:=TRUE, &#xD;
								Ext_Alarm:=Ext_AnalogControl.EXT_Alarm, &#xD;
								Int_Alarm:=Int_Alarm);	&#xD;
&#xD;
(*************************************************************************&#xD;
 *	SCALING INPUT&#xD;
 *************************************************************************)&#xD;
 &#xD;
HE_AIn_Module(Inp_AInModule:=Cfg_ModuleInput, &#xD;
							Out_RawValue_LoopBreak=&gt;Wrk_InpRawValue_LoopBreak, &#xD;
							Out_RawValue_X0=&gt;Wrk_InpRawValue_X0, &#xD;
							Out_RawValue_X1=&gt;Wrk_InpRawValue_X1, &#xD;
							Out_RawValue_Min=&gt;Wrk_InpRawValue_Min, &#xD;
							Out_RawValue_Max=&gt;Wrk_InpRawValue_Max);&#xD;
&#xD;
IF Inp_Feedback &lt;&gt; Wrk_InpRawValue_LoopBreak AND Inp_Feedback &gt; Wrk_InpRawValue_Min AND Inp_Feedback &lt; Wrk_InpRawValue_Max THEN&#xD;
	Ext_AnalogControl.EXT_Operator.Feedback := ScaleTrans(SclIn	:= INT_TO_REAL(Inp_Feedback),&#xD;
																					X0 := Wrk_InpRawValue_X0, &#xD;
																					Y0 := 0.0,&#xD;
																					X1 := Wrk_InpRawValue_X1, &#xD;
																					Y1 := 100.0);&#xD;
ELSE&#xD;
	Ext_AnalogControl.EXT_Operator.Feedback := Ext_AnalogControl.EXT_Operator.Feedback / Dummy;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	SCALING OUTPUT&#xD;
 *************************************************************************)&#xD;
 &#xD;
HE_AOut_Module(Inp_AOutModule:=Cfg_ModuleOutput, &#xD;
								Out_RawValue_X0=&gt;Wrk_OutRawValue_Y0, &#xD;
								Out_RawValue_X1=&gt;Wrk_OutRawValue_Y1, &#xD;
								Out_RawValue_Min=&gt;Wrk_OutRawValue_Min, &#xD;
								Out_RawValue_Max=&gt;Wrk_OutRawValue_Max);&#xD;
&#xD;
//Scales output after ramping, deadband and state control to output and structure&#xD;
IF NOT Wrk_Interlock THEN&#xD;
	Out_Output:=REAL_TO_INT(ScaleTrans(SclIn := Wrk_OutputOut, &#xD;
																					X0 := 0, &#xD;
																					Y0 := Wrk_OutRawValue_Y0, &#xD;
																					X1 := 100, &#xD;
																					Y1 := Wrk_OutRawValue_Y1));&#xD;
ELSE&#xD;
	Out_Output:=0;&#xD;
END_IF;&#xD;
&#xD;
LIMIT(MN:=Wrk_OutRawValue_Min, &#xD;
			In:=Wrk_OutputOut, &#xD;
			MX:=Wrk_OutRawValue_Max);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	STRUCTURE AND OUTPUT UPDATE&#xD;
 *************************************************************************)&#xD;
&#xD;
//Updates outputs&#xD;
Sts_AutoAvailable := Ext_AnalogControl.INT_Data.AutoAvailable;&#xD;
Sts_Fault:=Wrk_AlarmState;&#xD;
&#xD;
&#xD;
//Updates structure&#xD;
Ext_AnalogControl.EXT_Operator.Actual_Output :=  Wrk_OutputOut;&#xD;
Ext_AnalogControl.EXT_General.Process_TAG:=Cfg_ProcessTAG;&#xD;
Ext_AnalogControl.EXT_General.Controlled_FromController:=Cfg_ControllerTAG;&#xD;
Ext_AnalogControl.EXT_General.Connected_ControlCabinet:=Cfg_ControlCabinet;&#xD;
Ext_AnalogControl.INT_Data.AutoAvailable:=Ext_AnalogControl.EXT_Operator.Mode = 2 &#xD;
																		AND NOT Wrk_AlarmState&#xD;
																		AND NOT Wrk_Interlock;</Text></StructuredTextModel>