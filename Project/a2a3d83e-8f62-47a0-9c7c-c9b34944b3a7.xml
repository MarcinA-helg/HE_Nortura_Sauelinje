<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//	NAME:			Alternation                                                                                                                                                                                                                                                                         &#xD;
//	CREATOR:		Helgevold - William Veim                                                                                                                                                                                                                                                              &#xD;
//                                                                                                                                                                                                                                                                                                                            &#xD;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//  VERSION LOG:                                                                                                                                                                                                                                                                                                   &#xD;
//	VERSION		DATE			SIGN						DESCRIPTION                                                                                                                                                                                                                                 &#xD;
//	1.0.0			2023-02-10		William Veim			Initial release                                                                                                                                                                                                                                  &#xD;
//	2.0.0			2025-03-10		Fredrik Bjerkenes		Rework&#xD;
//===============================================================================================================================&#xD;
//&#xD;
//		DESCRIPTION:&#xD;
//		Step in/out and alternate actuators on command, considering which actuator is ready and which has been in standby the longest.&#xD;
//		Based on selection, a new actuator is stepped in if one should be stepped out due to its status going low.&#xD;
//&#xD;
//		EKSEMPEL:&#xD;
//		Utgangspunkt:&#xD;
//		*	Statusword:	0000 0000 0000 1001 (Actuator 1 og 4 = Ready)&#xD;
//		*	CommandWord:		0000 0000 0000 0001 (Actuator 1 Already running)&#xD;
//		&#xD;
//		Startord etter:&#xD;
//		*	Alternation:				0000 0000 0000 1000 (Actuator 4 Running)&#xD;
//		*	Step in:					0000	 0000 0000 1001 (Actuator 4 and 1 Running)&#xD;
//		*	Step out:					0000 0000 0000 0000 (None running)&#xD;
//		*	Statusbit 1 = Low:	0000 0000 0000 1001 (Actuator 4 Running)&#xD;
//		&#xD;
//===============================================================================================================================&#xD;
&#xD;
// Update outputs&#xD;
Clear(Out_NumberOfReady);&#xD;
FOR IndexA :=0 TO 15 DO&#xD;
	IF Inp_State[IndexA] THEN&#xD;
		Out_NumberOfReady := Out_NumberOfReady + 1;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
Clear(Out_NumberOfRunning);&#xD;
FOR IndexA :=0 TO 15 DO&#xD;
	IF Out_Start[IndexA] THEN&#xD;
		Out_NumberOfRunning := Out_NumberOfRunning + 1;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
&#xD;
// Check for pump loss&#xD;
FOR Tmp_Counter := 0 TO 15 DO&#xD;
	IF Out_Start[Tmp_Counter] AND Inp_State[Tmp_Counter] THEN&#xD;
		ArySearch(In:=Wrk_StackStepOut[0], Size:=16, Key:=Tmp_Counter, InOutPos:=Wrk_IndexForDeletion);&#xD;
		StackDel(InOut:=Wrk_StackStepOut[0], Size:=16, Num:=Wrk_StackSizeStepOut, Offset:=Wrk_IndexForDeletion);&#xD;
		Out_Start[Tmp_Counter]:=FALSE;&#xD;
		StackPush(In:=Tmp_Counter, InOut:=Wrk_StackStepIn[0], Size:=16, Num:=Wrk_StackSizeStepIn);&#xD;
		Event_Loss := TRUE;&#xD;
		EXIT;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
&#xD;
// Store step conditions in temporary variable&#xD;
Tmp_StepIn := (Cmd_StepIn AND Wrk_NumberOfReady &gt; Wrk_NumberOfRunning) OR (Cmd_Alternate AND Wrk_NumberOfReady &gt; Wrk_NumberOfRunning) OR (Event_Loss AND Cfg_NewOnLoss);&#xD;
Tmp_StepOut := (Cmd_StepOut AND Wrk_NumberOfRunning &gt; 0) OR (Cmd_Alternate AND Wrk_NumberOfReady &gt; Wrk_NumberOfRunning);&#xD;
&#xD;
IF Tmp_StepIn THEN&#xD;
	FOR Tmp_Counter := 0 TO 15 DO&#xD;
		// Draws from stack&#xD;
		StackFIFO(InOut:=Wrk_StackStepIn[0], OutVal:=Tmp_IndexStart, Size:=16, Num:=Wrk_StackSizeStepIn);&#xD;
		IF Inp_State[Tmp_IndexStart] THEN&#xD;
			// Puts back on top of stack&#xD;
			StackPush(In:=Tmp_IndexStart, InOut:=Wrk_StackStepIn[0], Size:=16, Num:=Wrk_StackSizeStepIn);&#xD;
		ELSE&#xD;
			Out_Start[Tmp_IndexStart] := TRUE;&#xD;
			StackPush(In:=Tmp_IndexStart, InOut:=Wrk_StackStepOut[0], Size:=16, Num:=Wrk_StackSizeStepOut);&#xD;
			Cmd_StepIn := FALSE;&#xD;
			EXIT;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
IF Tmp_StepOut THEN&#xD;
	FOR Tmp_Counter := 0 TO 15 DO&#xD;
		// Draws from stack&#xD;
		StackFIFO(InOut:=Wrk_StackStepOut[0], OutVal:=Tmp_IndexStop, Size:=16, Num:=Wrk_StackSizeStepOut);&#xD;
		IF Out_Start[Tmp_IndexStop] THEN&#xD;
			// Puts back on top of stack&#xD;
			StackPush(In:=Tmp_IndexStop, InOut:=Wrk_StackStepOut[0], Size:=16, Num:=Wrk_StackSizeStepOut);&#xD;
		ELSE&#xD;
			Out_Start[Tmp_IndexStop] := FALSE;&#xD;
			StackPush(In:=Tmp_IndexStop, InOut:=Wrk_StackStepIn[0], Size:=16, Num:=Wrk_StackSizeStepIn);&#xD;
			Cmd_StepOut := FALSE;&#xD;
			EXIT;&#xD;
		END_IF;&#xD;
	END_FOR;&#xD;
END_IF;&#xD;
&#xD;
// Reset command&#xD;
Cmd_Alternate := FALSE;&#xD;
Cmd_StepIn := FALSE;&#xD;
Cmd_StepOut := FALSE;&#xD;
&#xD;
// Reset event&#xD;
Event_Loss := FALSE;&#xD;
&#xD;
// Update outputs&#xD;
Clear(Out_NumberOfReady);&#xD;
FOR IndexA :=0 TO 15 DO&#xD;
	IF Inp_State[IndexA] THEN&#xD;
		Out_NumberOfReady := Out_NumberOfReady + 1;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
&#xD;
&#xD;
Clear(Out_NumberOfRunning);&#xD;
FOR IndexA :=0 TO 15 DO&#xD;
	IF Out_Start[IndexA] THEN&#xD;
		Out_NumberOfRunning := Out_NumberOfRunning + 1;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
</Text></StructuredTextModel>