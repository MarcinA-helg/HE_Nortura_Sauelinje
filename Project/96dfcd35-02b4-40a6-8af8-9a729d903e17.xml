<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//	NAME:			 HE_VFD_Logic                                                                                                                                                                                                                                                                    &#xD;
//	CREATOR:		 Jan Magne Dybvik, Helgevold Elektro                                                                                                                                                                                                                                             &#xD;
//                                                                                                                                                                                                                                                                                                                            &#xD;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//  VERSION LOG:                                                                                                                                                                                                                                                                                                   &#xD;
//	VERSION			DATE				SIGN						DESCRIPTION                                                                                                                                                                                                                                 &#xD;
//	1.0.0					27.02.2025		JMD							Initial Release&#xD;
//	1.0.1					15.04.2025		Ruben Byman			Bug fix Start Blocked state and state visible&#xD;
//	1.0.2					29.04.2025		Ruben Byman			Added action on fault and predefined output and alarm trigger&#xD;
//	1.0.3					06.05.2025		Ruben Byman			Changed Timer_StartTime from STRING to 2x INTs&#xD;
//	1.0.4					10.06.2025		Fredrik Bjerkenes		Added NOT infront of inp_loto in line 68(Start blocked)  and 195 (In case of interlock)&#xD;
// 1.0.5 				16.06.2025		Fredrik Bjerkenes 	Added Reset TOF to set reset fault TRUE for 500ms&#xD;
//===============================================================================================================================&#xD;
//&#xD;
//		DESCRIPTION:&#xD;
//		Common logic for VFD:&#xD;
//		- SCADA interaction&#xD;
//		- VFD Enabling&#xD;
//		- VFD mode selection and command/reference source&#xD;
//		- Runtime statistics&#xD;
//&#xD;
//==============================================================================================================================&#xD;
&#xD;
(*************************************************************************&#xD;
 *	INITIAL/SYSTEM VARIABELS&#xD;
 *************************************************************************)&#xD;
Wrk_CurrentTime := 					TruncTod(DT_TO_TOD(In:=GetTime()), _SEC);&#xD;
Wrk_Date_Now := 					DT_TO_DATE(GetTime());&#xD;
DtToDateStruct(In:=GetTime(), DateStruct=&gt;Wrk_DT_Struct);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	INITIALISING VARIABELS&#xD;
 *************************************************************************)&#xD;
&#xD;
IF NOT Wrk_Initialise THEN&#xD;
	//Operator settings&#xD;
	Ext_VFD.EXT_Operator.Manual_Gain:=50;&#xD;
	&#xD;
	//Engeneering settings&#xD;
	Ext_VFD.EXT_Engineering.Auto_MinOutput:=0;&#xD;
	Ext_VFD.EXT_Engineering.Auto_MaxOutput:=100;&#xD;
	Ext_VFD.EXT_Engineering.StateCfg_PreDefinedOutput:=50;&#xD;
	Ext_VFD.EXT_Engineering.RampTime_EngAuto:=60;&#xD;
	Ext_VFD.EXT_Engineering.RampTime_AdjMinMax:=60;&#xD;
	Ext_VFD.EXT_Engineering.Timer_Output:=10;&#xD;
	Ext_VFD.EXT_Engineering.Timer_RunTime:=10;&#xD;
	Ext_VFD.EXT_Engineering.Timer_StartTime_Hour:=12;&#xD;
	Ext_VFD.EXT_Engineering.Timer_StartTime_Minute:=00;&#xD;
	&#xD;
	//Alarm settings&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Cfg_DigAlarm_Delay:=10;&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Cfg_DigAlarm_UseReturnDelay:=TRUE;&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Cfg_SMS_Dig:=TRUE;&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Cfg_SMS_Technical:=TRUE;&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Cfg_PriorityLevel:=1;&#xD;
	&#xD;
	//Init complete&#xD;
	Wrk_Initialise:=TRUE;&#xD;
	&#xD;
END_IF;&#xD;
&#xD;
(*************************************************************************&#xD;
 *	GENERATING INTERNAL VARIABLES&#xD;
 *************************************************************************)&#xD;
&#xD;
// Blokker start av frekvensomformer ved Nødstopp, Sikkerhetsbryter eller Stopp fra frekvensomformer panel&#xD;
// Resettes på fallende flanke&#xD;
Wrk_Reset(Clk:=Ext_VFD.EXT_Engineering.Reset_Error);&#xD;
&#xD;
Wrk_StartBlocked := (Wrk_StartBlocked AND NOT Wrk_Reset.Q) OR Inp_STO OR NOT Inp_LOTO OR Inp_LocalStop;&#xD;
&#xD;
Wrk_AvailableAuto := 	Inp_Remote AND &#xD;
									Inp_Ready AND &#xD;
									Inp_Online AND NOT &#xD;
									Inp_Error AND &#xD;
									Ext_VFD.EXT_Operator.Mode = 2 AND NOT&#xD;
									Inp_ComFault AND NOT&#xD;
									Wrk_StartBlocked;&#xD;
												&#xD;
//Ser etter feil i frekvensomformer&#xD;
Ext_VFD.INT_Data.Fault := Inp_Error;&#xD;
&#xD;
// Delayed Communication Fault Alarm after CPU startup&#xD;
Wrk_CPUStartup(Clk:=(P_First_Run OR P_First_RunMode));&#xD;
Wrk_CPUStartupAlarmSupression(In:=Wrk_CPUStartup.Q, PT:= T#2s);&#xD;
&#xD;
//Ser om frekvensomformer er klar/tilgjengelig&#xD;
IF NOT Wrk_CPUStartupAlarmSupression.Q OR Wrk_AvailableAuto THEN&#xD;
	Ext_VFD.INT_Data.AutoAvailable := Wrk_AvailableAuto;&#xD;
END_IF;&#xD;
&#xD;
//Oppdaterer data for visning i SCADA&#xD;
//-----------------------------------------&#xD;
Ext_VFD.EXT_Operator.Auto_Visible:=Cfg_AutoInUse;&#xD;
&#xD;
Ext_VFD.EXT_Operator.Feedback_Gain := Inp_ActSpeed;&#xD;
&#xD;
&#xD;
Ext_VFD.EXT_Statistics.Power := Inp_Power;&#xD;
Ext_VFD.EXT_Statistics.Current := Inp_Current;&#xD;
&#xD;
&#xD;
Ext_VFD.INT_Data.CommunicationFault 	:= Inp_ComFault;&#xD;
Ext_VFD.INT_Data.Running						:= Inp_RunningFwd;&#xD;
Ext_VFD.EXT_General.Remote					:= NOT Inp_Remote;&#xD;
Ext_VFD.INT_Data.Warning 						:= Inp_Warning;&#xD;
Ext_VFD.INT_Data.Emergency_Stop 		:= Inp_STO;&#xD;
Ext_VFD.INT_Data.Fault							:= Inp_Error OR (Inp_ComFault AND NOT Wrk_CPUStartupAlarmSupression.Q);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	MODE CONTROL&#xD;
 *************************************************************************)&#xD;
&#xD;
CASE Ext_VFD.EXT_Operator.Mode OF&#xD;
		&#xD;
	    0://Av&#xD;
		&#xD;
				//Output control				&#xD;
				Wrk_CmdSpeedRef := 0.0;&#xD;
				Wrk_CmdRunFwd := FALSE;&#xD;
				&#xD;
		1://Man	&#xD;
		&#xD;
				//Output control&#xD;
				IF Ext_VFD.EXT_Operator.Manual_Gain &gt; 0.0  AND NOT Wrk_StartBlocked THEN&#xD;
					Wrk_CmdRunFwd := TRUE;&#xD;
					Wrk_CmdSpeedRef := Ext_VFD.EXT_Operator.Manual_Gain;&#xD;
				ELSE &#xD;
					Wrk_CmdRunFwd := FALSE;&#xD;
					Wrk_CmdSpeedRef := 0.0;&#xD;
				END_IF;&#xD;
				&#xD;
		2://Auto&#xD;
		&#xD;
				//Start control&#xD;
				IF Inp_AutoRunFwd AND Inp_AutoSpeedRef &gt; 0.5 AND NOT Wrk_StartBlocked THEN&#xD;
					Wrk_CmdRunFwd := TRUE;&#xD;
				ELSE  &#xD;
					Wrk_CmdRunFwd := FALSE;&#xD;
				END_IF;&#xD;
		&#xD;
				//Output control&#xD;
				IF Wrk_CmdRunFwd THEN&#xD;
				Wrk_CmdSpeedRef := ScaleTrans(&#xD;
									  	SclIn:=Inp_AutoSpeedRef, &#xD;
										X0:=0.0, &#xD;
										Y0:=Ext_VFD.EXT_Engineering.Auto_MinOutput, &#xD;
										X1:=100.0, &#xD;
										Y1:=Ext_VFD.EXT_Engineering.Auto_MaxOutput);&#xD;
				ELSE&#xD;
					Wrk_CmdSpeedRef:=0;&#xD;
				END_IF;&#xD;
				&#xD;
		3://Timer&#xD;
		&#xD;
				//Start control (based on time of day)&#xD;
				RE_TimerStart(Clk:=Wrk_CurrentTime = HE_INT2TOD(Hour:=Ext_VFD.EXT_Engineering.Timer_StartTime_Hour, Minute:=Ext_VFD.EXT_Engineering.Timer_StartTime_Minute));&#xD;
				&#xD;
				IF RE_TimerStart.Q THEN&#xD;
					Wrk_CmdRunFwd := TRUE;&#xD;
					Wrk_CmdSpeedRef := Ext_VFD.EXT_Engineering.Timer_Output;&#xD;
				ELSIF Wrk_TOD_TimedRun.Q THEN&#xD;
					Wrk_CmdRunFwd := FALSE;&#xD;
					Wrk_CmdSpeedRef := 0.0;&#xD;
				END_IF;&#xD;
&#xD;
END_CASE;&#xD;
&#xD;
Wrk_TOD_TimedRun(In:=Ext_VFD.EXT_Operator.Mode=3, PT:=SecToTime(Ext_VFD.EXT_Engineering.Timer_RunTime)); //Running time in timer mode&#xD;
&#xD;
(*************************************************************************&#xD;
 *	RAMPING OUTPUT&#xD;
 *************************************************************************)&#xD;
 &#xD;
 //Looking for change in min or max output &#xD;
IF Wrk_MinOutputSample &lt;&gt; Ext_VFD.EXT_Engineering.Auto_MinOutput THEN&#xD;
	Wrk_MinOrMax_Adjusted:=TRUE;&#xD;
ELSIF Wrk_MaxOutputSample &lt;&gt; Ext_VFD.EXT_Engineering.Auto_MaxOutput THEN&#xD;
	Wrk_MinOrMax_Adjusted:=TRUE;&#xD;
END_IF;&#xD;
Wrk_MinOutputSample:=Ext_VFD.EXT_Engineering.Auto_MinOutput;&#xD;
Wrk_MaxOutputSample:=Ext_VFD.EXT_Engineering.Auto_MaxOutput;&#xD;
&#xD;
&#xD;
TON_AutoEng(In:=Ext_VFD.EXT_Operator.Mode=2, PT:=SecToTime(Ext_VFD.EXT_Engineering.RampTime_EngAuto));&#xD;
TON_AutoMinMaxAdj(In:=Wrk_MinOrMax_Adjusted, PT:=SecToTime(Ext_VFD.EXT_Engineering.RampTime_AdjMinMax));&#xD;
&#xD;
IF Ext_VFD.EXT_Operator.Mode= 2 THEN&#xD;
	Wrk_RampTime :=SecToTime(Ext_VFD.EXT_Engineering.RampTime_EngAuto);&#xD;
ELSIF Wrk_MinOrMax_Adjusted THEN&#xD;
	Wrk_RampTime := SecToTime(Ext_VFD.EXT_Engineering.RampTime_AdjMinMax);&#xD;
ELSE&#xD;
	Wrk_RampTime:=TIME#0s;&#xD;
END_IF;&#xD;
&#xD;
Wrk_RampGain(ENS:=TRUE, &#xD;
						Inp_Value:=Wrk_CmdSpeedRef, &#xD;
						Cfg_StrokeTime:=Wrk_RampTime, &#xD;
						Cfg_Output_X0:=Ext_VFD.EXT_Engineering.Auto_MinOutput, &#xD;
						Cfg_Output_X1:=Ext_VFD.EXT_Engineering.Auto_MaxOutput, &#xD;
						Cfg_Resolution:=FALSE);&#xD;
&#xD;
IF TON_AutoEng.Q OR TON_AutoMinMaxAdj.Q OR Ext_VFD.EXT_Operator.Mode &lt;&gt; 2 THEN&#xD;
	Wrk_SpeedRamped := Wrk_CmdSpeedRef;//Henter pådrag direkte&#xD;
ELSE&#xD;
	Wrk_SpeedRamped := Wrk_RampGain.Out_Output;//Henter pådrag fra filter/ramp&#xD;
END_IF;&#xD;
&#xD;
IF NOT Inp_Remote OR NOT Inp_Ready OR NOT Inp_Online OR Inp_Error OR Inp_STO OR NOT Inp_LOTO OR Inp_ComFault  OR Wrk_StartBlocked OR Inp_Interlock THEN &#xD;
	Wrk_SpeedRamped := 0;//Legges til null ved feil eller forigling&#xD;
	Wrk_CmdRunFwd := FALSE; //Legger startbit til FALSE ved feil eller forrigling&#xD;
END_IF;&#xD;
&#xD;
(*************************************************************************&#xD;
 *	STATISTIC DATA&#xD;
 *************************************************************************)&#xD;
&#xD;
//Kjører statistikk basert på om frekvsenomformer kjører&#xD;
Wrk_Statistics(&#xD;
	Run:=Inp_RunningFwd, &#xD;
	Reset_Total:=Ext_VFD.EXT_Statistics.Reset_MotorTotal,&#xD;
	Reset_Service:=Ext_VFD.EXT_Statistics.Reset_MotorService);&#xD;
&#xD;
//Henter informasjon fra funksjonsblokk "HE_Statistikk"&#xD;
Ext_VFD.EXT_Statistics.ResetDate_MotorTotal					:= DateToString(Wrk_Statistics.ResetDate_Total);&#xD;
Ext_VFD.EXT_Statistics.ResetDate_MotorService 			:=	DateToString(Wrk_Statistics.ResetDate_Service);&#xD;
Ext_VFD.EXT_Statistics.OperatingHours_MotorTotal		:= LINT_TO_UDINT(TimeToSec(In:= Wrk_Statistics.RunTime_Total) / 3600);&#xD;
Ext_VFD.EXT_Statistics.OperatingHours_MotorService	:= LINT_TO_UDINT(TimeToSec(In:= Wrk_Statistics.RunTime_Service) / 3600);&#xD;
Ext_VFD.EXT_Statistics.NumberOfStarts 							:= Wrk_Statistics.NumberOfStarts;&#xD;
&#xD;
//Konvertering av driftstid på VFD&#xD;
Ext_VFD.EXT_Statistics.Ontime_VFD:=ULINT_TO_UDINT(Inp_VFD_TotalOnTime/24);&#xD;
Ext_VFD.EXT_Statistics.Runtime_VFD:=ULINT_TO_UDINT(Inp_VFD_TotalRunTime/24);&#xD;
&#xD;
//Setter reset dato for omformer når driftstimer blir nullstilt&#xD;
RE_ResetDatoOmformer(Clk:= Ext_VFD.EXT_Statistics.Runtime_VFD &lt; 1  AND NOT Inp_ComFault);&#xD;
&#xD;
IF RE_ResetDatoOmformer.Q THEN&#xD;
	Ext_VFD.EXT_Statistics.ResetDate_VFD := DateToString(Wrk_Date_Now);&#xD;
END_IF;&#xD;
&#xD;
//ENERGY CONSUMPTION&#xD;
//---------------------------&#xD;
&#xD;
Wrk_Energi := REAL_TO_UDINT(Inp_Energy *1000.0);&#xD;
&#xD;
IF Wrk_Today &lt;&gt; Wrk_DT_Struct.Day THEN&#xD;
	Wrk_Today := Wrk_DT_Struct.Day;&#xD;
	Wrk_Energi_Capture := Wrk_Energi;&#xD;
END_IF;&#xD;
&#xD;
IF Wrk_Energi_Capture &gt; Wrk_Energi THEN&#xD;
	Wrk_Energi_Capture := Wrk_Energi;&#xD;
END_IF;&#xD;
&#xD;
// Energiforbruk i dag&#xD;
Ext_VFD.EXT_Statistics.EnergyConsumption_Today:= UDINT_TO_REAL(Wrk_Energi - Wrk_Energi_Capture) / 1000.0;&#xD;
&#xD;
&#xD;
// STATE CONTROL&#xD;
//------------------&#xD;
&#xD;
//Resetter variabler før løkke&#xD;
Ext_VFD.EXT_General.Sts_Quality:=0;&#xD;
Wrk_ValueState:=	0;&#xD;
Wrk_AlarmState:=	FALSE;&#xD;
Wrk_AlarmSuffix:=	'';&#xD;
&#xD;
//VFD fault&#xD;
Ext_VFD.EXT_Engineering.StateCfg_1.Sts_State := Inp_Error;&#xD;
Ext_VFD.EXT_Engineering.StateCfg_1.Sts_Desc := 'VFD error';&#xD;
HE_StateControl(Inp_StateData:=Ext_VFD.EXT_Engineering.StateCfg_1, &#xD;
							Sts_Quality:=Ext_VFD.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState, &#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_VFD.EXT_Engineering.StateCfg_1.Sts_Visible:=TRUE;&#xD;
&#xD;
//VFD warning&#xD;
Ext_VFD.EXT_Engineering.StateCfg_2.Sts_State := Inp_Warning;&#xD;
Ext_VFD.EXT_Engineering.StateCfg_2.Sts_Desc := 'VFD warning';&#xD;
HE_StateControl(Inp_StateData:=Ext_VFD.EXT_Engineering.StateCfg_2, &#xD;
							Sts_Quality:=Ext_VFD.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_VFD.EXT_Engineering.StateCfg_2.Sts_Visible:=TRUE;&#xD;
&#xD;
//Communication fault&#xD;
Ext_VFD.EXT_Engineering.StateCfg_3.Sts_State := Inp_ComFault;&#xD;
Ext_VFD.EXT_Engineering.StateCfg_3.Sts_Desc := 'Communication fault';&#xD;
HE_StateControl(Inp_StateData:=Ext_VFD.EXT_Engineering.StateCfg_3, &#xD;
							Sts_Quality:=Ext_VFD.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_VFD.EXT_Engineering.StateCfg_3.Sts_Visible:=TRUE;&#xD;
&#xD;
//Emergency stop&#xD;
Ext_VFD.EXT_Engineering.StateCfg_4.Sts_State := Inp_STO;&#xD;
Ext_VFD.EXT_Engineering.StateCfg_4.Sts_Desc := 'Emergency stop';&#xD;
HE_StateControl(Inp_StateData:=Ext_VFD.EXT_Engineering.StateCfg_4, &#xD;
							Sts_Quality:=Ext_VFD.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_VFD.EXT_Engineering.StateCfg_4.Sts_Visible:=Cfg_STO_InUse;&#xD;
&#xD;
//LOTO/Service breaker&#xD;
Ext_VFD.EXT_Engineering.StateCfg_5.Sts_State := NOT Inp_LOTO;&#xD;
Ext_VFD.EXT_Engineering.StateCfg_5.Sts_Desc := 'LOTO';&#xD;
HE_StateControl(Inp_StateData:=Ext_VFD.EXT_Engineering.StateCfg_5, &#xD;
							Sts_Quality:=Ext_VFD.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_VFD.EXT_Engineering.StateCfg_5.Sts_Visible:=Cfg_LOTO_InUse;&#xD;
&#xD;
//Interlock&#xD;
Ext_VFD.EXT_Engineering.StateCfg_6.Sts_State := Inp_Interlock;&#xD;
Ext_VFD.EXT_Engineering.StateCfg_6.Sts_Desc := 'Interlock';&#xD;
HE_StateControl(Inp_StateData:=Ext_VFD.EXT_Engineering.StateCfg_6, &#xD;
							Sts_Quality:=Ext_VFD.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_VFD.EXT_Engineering.StateCfg_6.Sts_Visible:=Cfg_Interlock_InUse;&#xD;
&#xD;
//Start blocked&#xD;
Ext_VFD.EXT_Engineering.StateCfg_7.Sts_State := Wrk_StartBlocked;&#xD;
Ext_VFD.EXT_Engineering.StateCfg_7.Sts_Desc := 'Start blocked';&#xD;
HE_StateControl(Inp_StateData:=Ext_VFD.EXT_Engineering.StateCfg_7, &#xD;
							Sts_Quality:=Ext_VFD.EXT_General.Sts_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_VFD.EXT_Engineering.StateCfg_7.Sts_Visible:=TRUE;&#xD;
&#xD;
CASE Wrk_ValueState OF&#xD;
	&#xD;
	0://Continue operation&#xD;
	Wrk_SpeedRefOutput:= Wrk_SpeedRamped;&#xD;
	&#xD;
	1://Freeze output&#xD;
	Wrk_SpeedRefOutput:=Wrk_SpeedRefOutput;&#xD;
	&#xD;
	2://Predefined output&#xD;
	Wrk_SpeedRefOutput:=Ext_VFD.EXT_Engineering.StateCfg_PreDefinedOutput;&#xD;
	&#xD;
END_CASE;&#xD;
&#xD;
&#xD;
//Setter pådrag basert på aktuell verdi fra styring&#xD;
Ext_VFD.EXT_Operator.Actual_Gain := Wrk_SpeedRefOutput;&#xD;
Val_SpeedRef := Ext_VFD.EXT_Operator.Actual_Gain;&#xD;
&#xD;
// ALARM CONTROL&#xD;
//---------------------&#xD;
&#xD;
//Suppress state&#xD;
Ext_VFD.EXT_Alarm.EXT_Engineering.Sts_Suppressed := Inp_AlmSuppress OR (Cfg_AlmSuppress_IfOff AND Ext_VFD.EXT_Operator.Mode = 0);&#xD;
IF Inp_AlmSuppress THEN&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Sts_SuppressedDesc := Inp_AlmSuppressDesc;&#xD;
ELSIF Cfg_AlmSuppress_IfOff AND Ext_VFD.EXT_Operator.Mode = 0 THEN&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Sts_SuppressedDesc := 'Off mode';&#xD;
ELSE&#xD;
	Ext_VFD.EXT_Alarm.EXT_Engineering.Sts_SuppressedDesc := '';&#xD;
END_IF;&#xD;
&#xD;
Wrk_AlarmGeneral.Inp_Connected_Cabinet:=				Ext_VFD.EXT_Engineering.Supply_Switchboard;&#xD;
Wrk_AlarmGeneral.Inp_Process_Desc:=							Ext_VFD.EXT_General.Process_Desc;&#xD;
Wrk_AlarmGeneral.Inp_Process_TAG:=							Ext_VFD.EXT_General.VFD_TAG;&#xD;
Wrk_AlarmGeneral.Inp_Process_Suffix:=							Wrk_AlarmSuffix;&#xD;
Wrk_AlarmGeneral.Inp_Connected_Controller:=				''; &#xD;
Wrk_AlarmGeneral.Inp_Process_Value:=							'';&#xD;
Wrk_AlarmGeneral.Inp_Trigger := 									Wrk_AlarmState;&#xD;
&#xD;
Wrk_AlarmGeneral(ENS:=TRUE, &#xD;
								Ext_Alarm:=Ext_VFD.EXT_Alarm, &#xD;
								Int_Alarm:=Int_Alarm);&#xD;
&#xD;
// FEILDBUS OUTPUT&#xD;
//------------------&#xD;
Out_Enable:=  Inp_Online AND Inp_VoltageEnabled AND NOT Inp_STO AND NOT Wrk_StartBlocked;// Switch on / Contactor command&#xD;
Out_RunFwd := Wrk_CmdRunFwd AND Inp_Ready; // Run Fwd&#xD;
&#xD;
// Pulse Auto Reset&#xD;
Wrk_ResetError_VFD(In:=Ext_VFD.EXT_Engineering.Reset_Error, PT:=TIME#500ms);&#xD;
&#xD;
Out_FaultReset := Wrk_ResetError_VFD.Q ; // Reset fault&#xD;
&#xD;
// Updating FB output&#xD;
Sts_AvailableAuto := Ext_VFD.INT_Data.AutoAvailable;&#xD;
Sts_Interlock := Inp_Interlock;&#xD;
Sts_RunningFwd := Inp_RunningFwd;&#xD;
&#xD;
// Reset flow caluclation (FB will be after VFD FB, in case of use the caluculation block will set true)&#xD;
Ext_VFD.EXT_Operator.CalculatedFlow_Visible:=FALSE;&#xD;
Ext_VFD.EXT_Operator.CalculatedFlow_Value:=0;&#xD;
Ext_VFD.EXT_Operator.CalculatedFlow_Unit:='';&#xD;
&#xD;
// Reset SCADA Comands&#xD;
Ext_VFD.EXT_Engineering.Reset_Error := FALSE; &#xD;
Ext_VFD.EXT_Statistics.Reset_MotorService := FALSE;&#xD;
Ext_VFD.EXT_Statistics.Reset_MotorTotal := FALSE;&#xD;
</Text></StructuredTextModel>