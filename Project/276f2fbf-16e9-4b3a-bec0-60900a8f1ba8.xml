<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//	NAME:					HE_SNMP_EncodeOID&#xD;
//	CREATOR:				Helgevold - Jan Magne Dybvik&#xD;
// REQUIREMENTS: NX CPU&#xD;
//&#xD;
// DESCRTIPTION: 	Koder SNMP Objekt identifiseringsverdi&#xD;
//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&#xD;
//  VERSION LOG:&#xD;
//	 VERSION			DATE				SIGN							DESCRIPTION&#xD;
//	 1.0.0				2024-05-15		Jan Magne Dybvik		Initial release&#xD;
//  1.0.1				2025-05-06		Jan Magne Dybvik		Bugfix, Mask 7 lsb i last byte&#xD;
//&#xD;
//================================================================================================================================&#xD;
&#xD;
// Initalize&#xD;
Wrk_BufferUB := UPPER_BOUND(Ext_Buffer, 1);&#xD;
Wrk_BufferLB := LOWER_BOUND(Ext_Buffer, 1);&#xD;
Wrk_ExtBufferSize := Wrk_BufferUB - Wrk_BufferLB + 1;&#xD;
Wrk_Size :=0;&#xD;
Wrk_OID := Inp_OID;&#xD;
&#xD;
// Type: Object Identifier&#xD;
Wrk_Buffer[0] := 16#06;&#xD;
&#xD;
// First OID Number&#xD;
Wrk_DelimiterPos := FIND(In1:=Wrk_OID, In2:='.'); 														// Locate delimiter&#xD;
Wrk_Val := STRING_TO_UINT(In:=LEFT(In:=Wrk_OID, L:=Wrk_DelimiterPos - 1)) * 40;	// Extract number&#xD;
Wrk_OID := DELETE(In:=Wrk_OID, L:=Wrk_DelimiterPos, P:=1);										// Delete number and delimiter&#xD;
&#xD;
// Second OID number&#xD;
Wrk_DelimiterPos := FIND(In1:=Wrk_OID, In2:='.');																		// Locate delimiter&#xD;
Wrk_Val := Wrk_Val + STRING_TO_UINT(In:=LEFT(In:=Wrk_OID, L:=Wrk_DelimiterPos - 1));		// Extract number&#xD;
Wrk_OID := DELETE(In:=Wrk_OID, L:=Wrk_DelimiterPos, P:=1);													// Delete number and delimiter&#xD;
&#xD;
// First and second number&#xD;
Wrk_Buffer[2] := UINT_TO_BYTE(Wrk_Val);	// Add numbers to array&#xD;
Wrk_OIDSize := 1;&#xD;
&#xD;
// Add following numbers&#xD;
REPEAT &#xD;
    Wrk_DelimiterPos := FIND(In1:=Wrk_OID, In2:='.');														// Locate delimiter&#xD;
	Wrk_Val := STRING_TO_UINT(In:=LEFT(In:=Wrk_OID, L:=Wrk_DelimiterPos - 1));		// Extract number&#xD;
	Wrk_OID := DELETE(In:=Wrk_OID, L:=Wrk_DelimiterPos, P:=1);									// Delete number and delimiter&#xD;
	&#xD;
	IF Wrk_Val &gt; 16#7F THEN // If value &gt; 127 use a second byte&#xD;
		Wrk_Buffer[2+Wrk_OIDSize] := WORD_TO_BYTE(SHR(UINT_TO_WORD(Wrk_Val) , USINT#7)) OR BYTE#16#80;		// Add MSB to array&#xD;
		Wrk_OIDSize := Wrk_OIDSize + 1;																									// Increment array size&#xD;
		Wrk_Val := WORD_TO_UINT((UINT_TO_WORD(Wrk_Val) &amp; WORD#16#FF) ); 	// Set most significant byte to indicate use of a second byte&#xD;
	END_IF;&#xD;
	&#xD;
	Wrk_Buffer[2+Wrk_OIDSize] := UINT_TO_BYTE(Wrk_Val)  &amp; BYTE#16#7F;	// Add number (LSB) to array, and mask 7 lsb&#xD;
	Wrk_OIDSize := Wrk_OIDSize + 1;										// Increment array size&#xD;
	&#xD;
UNTIL Wrk_DelimiterPos = 0 													// No delimiter found&#xD;
END_REPEAT;&#xD;
&#xD;
&#xD;
// Object Size&#xD;
Wrk_Buffer[1] :=USINT_TO_BYTE(Wrk_OIDSize);&#xD;
&#xD;
// Copy object to external buffer&#xD;
Wrk_Size := Wrk_OIDSize + 2;		// Number of bytes to copy&#xD;
IF Wrk_Size &lt;= Wrk_ExtBufferSize THEN	// External buffer has space&#xD;
	MemCopy(In:=Wrk_Buffer[0], AryOut:=Ext_Buffer[Wrk_BufferLB], Size:=Wrk_Size);&#xD;
ELSE&#xD;
	Wrk_Size := 0;&#xD;
END_IF;&#xD;
&#xD;
HE_SNMP_EncodeOID := Wrk_Size;	// Return number of bytes added to external array</Text></StructuredTextModel>