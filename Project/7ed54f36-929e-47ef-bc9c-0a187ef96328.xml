<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//	NAME:			 HE_AnalogInput_Logic                                                                                                                                                                                                                                                               &#xD;
//	CREATOR:		 William Veim, Helgevold Elektro                                                                                                                                                                                                                                             &#xD;
//                                                                                                                                                                                                                                                                                                                            &#xD;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//  VERSION LOG:                                                                                                                                                                                                                                                                                                   &#xD;
//	VERSION			DATE				SIGN						DESCRIPTION                                                                                                                                                                                                                                 &#xD;
//	1.0.0					16.04.2025		William Veim			Initial Release&#xD;
//	1.0.1					29.04.2025		Ruben Byman			Added alarm trigger, alarm suppression, bug fix state control action and stopped execution of Average in case of module fault&#xD;
// 1.0.2					23.06.2025		Jan Magne Dybvik	Replaced Ext_AnalogValue.EXT_Operator.ProcessValue with Wrk_ProcessValue for check ProcessValueOutOfRange to avoid it interfering with itself&#xD;
// 1.0.3					24.06.2025		Jan Magne Dybvik	Added HE_Real2String to create process value for SMS message&#xD;
//	1.0.4					24.06.2025		Fredrik Bjerkenes 	Added HE_Real2String to create Process Value for SMS message in AlarmAnalog&#xD;
// 1.0.5					24.06.2025		Jan Magne Dybvik	Moved assignment of  Ext_AnalogValue.EXT_General.Process_Unit to bottom of block&#xD;
//===============================================================================================================================&#xD;
//&#xD;
//		DESCRIPTION:&#xD;
//		TO BE SET&#xD;
//&#xD;
//===============================================================================================================================&#xD;
&#xD;
(*************************************************************************&#xD;
 *	INITIAL/SYSTEM VARIABELS&#xD;
 *************************************************************************)&#xD;
 TON_InitialCycles(In:=TRUE, PT:=TIME#10s); //10sec delay after startup (establish communication)&#xD;
 Wrk_Date_Now :=DT_TO_DATE(GetTime());&#xD;
 Wrk_CurrentTime := TruncTod(DT_TO_TOD(In:=GetTime()), _SEC);&#xD;
 &#xD;
 RE_MidnightPulse(Clk:=Wrk_CurrentTime=TIME_OF_DAY#00:00:00.00);&#xD;
 &#xD;
 (*************************************************************************&#xD;
 *	INITIALIZE VARIABELS&#xD;
 *************************************************************************)&#xD;
 &#xD;
 Ext_AnalogValue.EXT_Engineering.Active:=TRUE;&#xD;
&#xD;
IF 0 &lt;&gt;  Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0 AND NOT Wrk_ProscessValueMinInit AND Ext_AnalogValue.EXT_Engineering.ProcessValue_MinLevel = 0 THEN //IF change, initialize to scaling value&#xD;
	Ext_AnalogValue.EXT_Engineering.ProcessValue_MinLevel:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0;&#xD;
	Wrk_ProscessValueMinInit:=TRUE;&#xD;
END_IF;&#xD;
 &#xD;
IF 0 &lt;&gt;  Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1 AND NOT Wrk_ProscessValueMaxInit AND Ext_AnalogValue.EXT_Engineering.ProcessValue_MaxLevel = 0 THEN //IF change, initialize to scaling value&#xD;
	Ext_AnalogValue.EXT_Engineering.ProcessValue_MaxLevel:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1;&#xD;
	Wrk_ProscessValueMaxInit:=TRUE;&#xD;
END_IF;&#xD;
&#xD;
//Reads input value&#xD;
Wrk_InputValue:= Inp_Value;&#xD;
Wrk_LoopBreak:=Inp_LoopBreak;&#xD;
&#xD;
&#xD;
IF NOT Wrk_Initialise THEN&#xD;
	&#xD;
	//Engeneering settings&#xD;
	Ext_AnalogValue.EXT_Engineering.StateCfg_InputStuckTimeDelay:=10;&#xD;
	Ext_AnalogValue.EXT_Engineering.StateCfg_InputStuckDiffThreshold:=10;&#xD;
	Ext_AnalogValue.EXT_Engineering.Avg_NumberOfValues:=50;&#xD;
	Ext_AnalogValue.EXT_Engineering.Avg_SampleInterval:=50;&#xD;
	&#xD;
	//Alarm settings&#xD;
	Ext_AnalogValue.EXT_Alarm.EXT_Engineering.Cfg_PriorityLevel:=1;&#xD;
	Ext_AnalogValue.EXT_Alarm.EXT_Engineering.Cfg_DigAlarm_Delay:=10;&#xD;
	Ext_AnalogValue.EXT_Alarm.EXT_Engineering.Cfg_DigAlarm_UseReturnDelay:=TRUE;&#xD;
	Ext_AnalogValue.EXT_AlarmAnalog.EXT_Engineering.Cfg_FullAlarm_Delay:=10;&#xD;
	Ext_AnalogValue.EXT_AlarmAnalog.EXT_Engineering.Cfg_FullAlarm_UseReturnDelay:=TRUE;&#xD;
	Ext_AnalogValue.EXT_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_Delay:=10;&#xD;
	Ext_AnalogValue.EXT_AlarmAnalog.EXT_Engineering.Cfg_FullAlarm_UseReturnDelay:=TRUE;&#xD;
	Ext_AnalogValue.EXT_AlarmAnalog.EXT_Engineering.SMS_Full:=TRUE;&#xD;
	Ext_AnalogValue.EXT_AlarmAnalog.EXT_Engineering.SMS_Pre:=TRUE;&#xD;
&#xD;
	//Init complete&#xD;
	Wrk_Initialise:=TRUE;&#xD;
	&#xD;
END_IF;&#xD;
&#xD;
(*************************************************************************&#xD;
 *	FAULT AND STATE CONTROL&#xD;
 *************************************************************************)&#xD;
&#xD;
// FAULT CONTROL&#xD;
//--------------------&#xD;
Wrk_DiffCheck(ENS:=Wrk_ValueState=0 AND Ext_AnalogValue.EXT_Engineering.StateCfg_InputStuckVisible, //DiffCheck only active if "UseValue" (not to be checked if "hold value" or "pre defined value")&#xD;
							Input:=Ext_AnalogValue.EXT_Operator.ProcessValue, &#xD;
							MaxValue:=Ext_AnalogValue.EXT_Engineering.ProcessValue_MaxLevel, &#xD;
							AllowedDeviation:=Ext_AnalogValue.EXT_Engineering.StateCfg_InputStuckDiffThreshold, &#xD;
							Delay:=SecToTime(Ext_AnalogValue.EXT_Engineering.StateCfg_InputStuckTimeDelay));&#xD;
&#xD;
Wrk_InputStuck:= Wrk_DiffCheck.Fault AND Ext_AnalogValue.EXT_Engineering.StateCfg_InputStuckVisible;&#xD;
&#xD;
TON_ProcessValueOutOfRange(In:=Ext_AnalogValue.EXT_Engineering.ProcessValue_MinLevel &gt; Wrk_ProcessValue&#xD;
														OR Ext_AnalogValue.EXT_Engineering.ProcessValue_MaxLevel &lt; Wrk_ProcessValue, &#xD;
													PT:=TIME#10s);&#xD;
&#xD;
Wrk_ProcessValueOutOfRange := TON_ProcessValueOutOfRange.Q;&#xD;
&#xD;
Wrk_ModuleFault:= Inp_ModuleFault AND TON_InitialCycles.Q;&#xD;
&#xD;
// STATE CONTROL&#xD;
//------------------&#xD;
&#xD;
//Resetter variabler før løkke&#xD;
Ext_AnalogValue.EXT_General.State_Quality := 0;&#xD;
Wrk_ValueState:=	0;&#xD;
Wrk_AlarmState:=	FALSE;&#xD;
Wrk_AlarmSuffix:=	'';&#xD;
&#xD;
//Process value out of range&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_1.Sts_State := Wrk_ProcessValueOutOfRange;&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_1.Sts_Desc := 'Process value out of range';&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogValue.EXT_Engineering.StateCfg_1, &#xD;
							Sts_Quality:=Ext_AnalogValue.EXT_General.State_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
&#xD;
//Module fault&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_2.Sts_State := Wrk_ModuleFault;&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_2.Sts_Desc := 'Module fault';&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogValue.EXT_Engineering.StateCfg_2, &#xD;
							Sts_Quality:=Ext_AnalogValue.EXT_General.State_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
&#xD;
//Value Stuck&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_3.Sts_State := Wrk_InputStuck;&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_3.Sts_Desc := 'Value stuck';&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogValue.EXT_Engineering.StateCfg_3, &#xD;
							Sts_Quality:=Ext_AnalogValue.EXT_General.State_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_3.Sts_Visible:=Ext_AnalogValue.EXT_Engineering.StateCfg_InputStuckVisible;&#xD;
&#xD;
//According to input&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_4.Sts_State := Inp_State4_State;&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_4.Sts_Desc := Inp_State4_Desc;&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogValue.EXT_Engineering.StateCfg_4, &#xD;
							Sts_Quality:=Ext_AnalogValue.EXT_General.State_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_4.Sts_Visible:=Cfg_State4_InUse;&#xD;
&#xD;
//According to input&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_5.Sts_State := Inp_State5_State;&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_5.Sts_Desc := Inp_State5_Desc;&#xD;
HE_StateControl(Inp_StateData:=Ext_AnalogValue.EXT_Engineering.StateCfg_5, &#xD;
							Sts_Quality:=Ext_AnalogValue.EXT_General.State_Quality, &#xD;
							Sts_ValueState:=Wrk_ValueState,&#xD;
							Sts_AlarmSuffix:=Wrk_AlarmSuffix,&#xD;
							Sts_AlarmState:=Wrk_AlarmState);&#xD;
Ext_AnalogValue.EXT_Engineering.StateCfg_5.Sts_Visible:=Cfg_State5_InUse;&#xD;
&#xD;
(*************************************************************************&#xD;
 *	ALARM CONTROL&#xD;
 *************************************************************************)&#xD;
&#xD;
Wrk_AlarmGeneral.Inp_Trigger:=									Wrk_AlarmState;&#xD;
Wrk_AlarmGeneral.Inp_Connected_Cabinet:=			Cfg_ControlCabinet;&#xD;
Wrk_AlarmGeneral.Inp_Connected_Controller:=			Cfg_ControllerTAG;&#xD;
Wrk_AlarmGeneral.Inp_Process_TAG:=						Cfg_ProcessTAG;&#xD;
Wrk_AlarmGeneral.Inp_AlarmSupress:=						Inp_AlmSuppress;&#xD;
Wrk_AlarmGeneral.Inp_AlmSuppressDesc:=				Inp_AlmSuppressDesc;&#xD;
Wrk_AlarmGeneral.Inp_Process_Desc:=						Ext_AnalogValue.EXT_General.Process_Desc;&#xD;
Wrk_AlarmGeneral.Inp_Process_Suffix:=						Wrk_AlarmSuffix;&#xD;
Wrk_AlarmGeneral.Inp_Process_Value:=						HE_REAL2STRING(Inp := Ext_AnalogValue.EXT_Operator.ProcessValue,&#xD;
													  															 Cfg_Unit := Cfg_ProcessValue_Unit,&#xD;
																												 Cfg_SignificantDigits := Cfg_AlarmSMS_SignificantDigits,&#xD;
																												 Cfg_UsePrefix := Cfg_AlarmSMS_UseUnitPrefix);&#xD;
&#xD;
Wrk_AlarmAnalog.Inp_Quality:=									Ext_AnalogValue.EXT_General.State_Quality;&#xD;
Wrk_AlarmAnalog.Inp_AlarmToken:=							Wrk_AlarmGeneral.Out_AlarmToken;&#xD;
Wrk_AlarmAnalog.Inp_Process_Value:=						Wrk_ProcessValue;&#xD;
Wrk_AlarmAnalog.Inp_Process_Value_String:=			HE_REAL2STRING(Inp := Ext_AnalogValue.EXT_Operator.ProcessValue,&#xD;
													  															 Cfg_Unit := Ext_AnalogValue.EXT_General.Process_Unit,&#xD;
																												 Cfg_SignificantDigits := Cfg_AlarmSMS_SignificantDigits,&#xD;
																												 Cfg_UsePrefix := Cfg_AlarmSMS_UseUnitPrefix);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	EXCECUTING ALARM BLOCKS&#xD;
 *************************************************************************)&#xD;
 &#xD;
Wrk_AlarmGeneral(ENS:=TRUE, &#xD;
								Ext_Alarm:=Ext_AnalogValue.EXT_Alarm, &#xD;
								Int_Alarm:=Int_Alarm,&#xD;
								Out_AlarmToken=&gt;Wrk_AlarmToken);	&#xD;
&#xD;
&#xD;
Wrk_AlarmAnalog(ENS:=TRUE, &#xD;
								Int_Alarm:=Int_Alarm, &#xD;
								Ext_AlarmAnalog:=Ext_AnalogValue.EXT_AlarmAnalog, &#xD;
								Ext_AlarmGeneral:=Ext_AnalogValue.EXT_Alarm);&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	CALIBRATION (X0, X1, Y0, Y1 CONTROL)&#xD;
 *************************************************************************)&#xD;
 &#xD;
IF NOT Cfg_ValueType THEN&#xD;
	//No calibration&#xD;
	IF NOT Ext_AnalogValue.EXT_Engineering.Calibrate_LowerVisible AND NOT Ext_AnalogValue.EXT_Engineering.Calibrate_UpperVisible THEN&#xD;
		Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X0		:= Cfg_SignalValue_Y0;&#xD;
		Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X1		:= Cfg_SignalValue_Y1;&#xD;
	END_IF;&#xD;
&#xD;
	//Lower calibration (X0-Y0)&#xD;
	IF Ext_AnalogValue.EXT_Engineering.Calibrate_LowerVisible  THEN&#xD;
		IF Ext_AnalogValue.EXT_Engineering.Calibrate_Lower THEN&#xD;
			Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X0 		:= Wrk_InputValue;&#xD;
			Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0 		:= Ext_AnalogValue.EXT_Engineering.CalibrateValue_Lower;&#xD;
			Ext_AnalogValue.EXT_Engineering.Calibrate_Lower 				:= FALSE;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
&#xD;
	//Upper calibration (X1-Y1)&#xD;
	IF Ext_AnalogValue.EXT_Engineering.Calibrate_UpperVisible THEN&#xD;
		IF Ext_AnalogValue.EXT_Engineering.Calibrate_Upper THEN&#xD;
			Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X1 		:= Wrk_InputValue;&#xD;
			Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1 		:= Ext_AnalogValue.EXT_Engineering.CalibrateValue_Upper;&#xD;
			Ext_AnalogValue.EXT_Engineering.Calibrate_Upper				:= FALSE;&#xD;
		END_IF;&#xD;
	END_IF;&#xD;
ELSE&#xD;
	Ext_AnalogValue.EXT_Engineering.Calibrate_LowerVisible:=FALSE;&#xD;
	Ext_AnalogValue.EXT_Engineering.Calibrate_UpperVisible:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
(*************************************************************************&#xD;
 *	PROCESS VALUE CONTROL&#xD;
 *************************************************************************)&#xD;
 &#xD;
 IF Ext_AnalogValue.EXT_Engineering.ProcessValue_MinLevel &lt; Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0 THEN&#xD;
 	Wrk_MinValue:=Ext_AnalogValue.EXT_Engineering.ProcessValue_MinLevel;&#xD;
 ELSIF Ext_AnalogValue.EXT_Engineering.ProcessValue_MinLevel &gt; Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0 THEN&#xD;
	 Wrk_MinValue:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0;&#xD;
 ELSE&#xD;
	 Wrk_MinValue:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0;&#xD;
 END_IF;&#xD;
 &#xD;
 IF Ext_AnalogValue.EXT_Engineering.ProcessValue_MaxLevel &lt; Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1 THEN&#xD;
 	Wrk_MaxValue:= Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1;&#xD;
 ELSIF Ext_AnalogValue.EXT_Engineering.ProcessValue_MaxLevel &gt; Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1 THEN&#xD;
 	Wrk_MaxValue:= Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0;&#xD;
 ELSE&#xD;
	 Wrk_MinValue:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0;&#xD;
 END_IF;&#xD;
 &#xD;
 //Limits value&#xD;
 Ext_AnalogValue.EXT_Operator.ProcessValue:=LIMIT(MN:=Wrk_MinValue, &#xD;
																						 In:=Ext_AnalogValue.EXT_Operator.ProcessValue, &#xD;
																						 MX:=Wrk_MaxValue);&#xD;
 &#xD;
  (*************************************************************************&#xD;
 *	SIMULATION OF PROCESS OR SIGNAL VALUE&#xD;
 *************************************************************************)&#xD;
 &#xD;
 IF Ext_AnalogValue.EXT_Engineering.Simulate_ProcessValue_Active THEN&#xD;
	 Wrk_InputValue:= ScaleTrans(SclIn:=Ext_AnalogValue.EXT_Engineering.Simulate_ProcessValue_Value, &#xD;
													 X0:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0, &#xD;
													 Y0:=Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X0, &#xD;
													 X1:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1, &#xD;
													 Y1:=Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X1);&#xD;
	 Ext_AnalogValue.EXT_General.State_Quality:=3; //QUALITY TO SIMULATE&#xD;
 ELSIF Ext_AnalogValue.EXT_Engineering.Simulate_SignalValue_Active THEN&#xD;
	 Wrk_InputValue:= Ext_AnalogValue.EXT_Engineering.Simulate_SignalValue_Value;&#xD;
	 Ext_AnalogValue.EXT_General.State_Quality:=3; //QUALITY TO SIMULATE&#xD;
 END_IF;&#xD;
 &#xD;
 IF Ext_AnalogValue.EXT_Engineering.Simulate_ProcessValue_Active&#xD;
	 AND Ext_AnalogValue.EXT_Engineering.Simulate_SignalValue_Active THEN&#xD;
	 Ext_AnalogValue.EXT_Engineering.Simulate_ProcessValue_Active:=FALSE;&#xD;
 END_IF;&#xD;
 &#xD;
 IF Cfg_ValueType THEN &#xD;
 	Ext_AnalogValue.EXT_Engineering.Simulate_SignalValue_Active:=FALSE;&#xD;
 END_IF;&#xD;
 &#xD;
 Ext_AnalogValue.EXT_Engineering.Simulate_ProcessValue_Value:=LIMIT(MN:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0, &#xD;
																													 In:=Ext_AnalogValue.EXT_Engineering.Simulate_ProcessValue_Value, &#xD;
																													 MX:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1);&#xD;
&#xD;
Ext_AnalogValue.EXT_Engineering.Simulate_SignalValue_Value:=LIMIT(MN:=Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X0, &#xD;
																													In:=Ext_AnalogValue.EXT_Engineering.Simulate_SignalValue_Value, &#xD;
																													MX:=Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X1);&#xD;
&#xD;
 (*************************************************************************&#xD;
 *	INPUT VALUE CONTROL AND AVERAGE &#xD;
 *************************************************************************)&#xD;
 &#xD;
//AVERAGE INPUT VALUE&#xD;
Wrk_Average(&#xD;
	ENS									:=NOT Wrk_ModuleFault AND NOT Wrk_LoopBreak,&#xD;
	Inp_Value							:=	Wrk_InputValue, &#xD;
	Cfg_NumberOfValues		:= Ext_AnalogValue.EXT_Engineering.Avg_NumberOfValues, &#xD;
	Cfg_SamplingInterval		:=	Ext_AnalogValue.EXT_Engineering.Avg_SampleInterval);&#xD;
 &#xD;
 &#xD;
IF NOT Cfg_ValueType THEN //Input value is signal value (mA value)&#xD;
	Ext_AnalogValue.EXT_Engineering.SignalValue_Visible :=		TRUE;&#xD;
	&#xD;
	IF NOT Wrk_LoopBreak THEN&#xD;
	Ext_AnalogValue.EXT_Engineering.SignalValue :=  					Wrk_Average.Out_Average;&#xD;
	Wrk_ProcessValue :=																ScaleTrans(SclIn:=Ext_AnalogValue.EXT_Engineering.SignalValue, &#xD;
																														X0:=Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X0, &#xD;
																														Y0:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y0, &#xD;
																														X1:=Ext_AnalogValue.EXT_Engineering.SignalValue_Scale_X1, &#xD;
																														Y1:=Ext_AnalogValue.EXT_Engineering.ProcessValue_Scale_Y1);&#xD;
	ELSE&#xD;
		Ext_AnalogValue.EXT_Engineering.SignalValue:= Ext_AnalogValue.EXT_Engineering.SignalValue / Wrk_Dummy; //Might look for a better solution &#xD;
		Wrk_ProcessValue :=Wrk_ProcessValue / Wrk_Dummy;&#xD;
	END_IF;&#xD;
	&#xD;
ELSE	//Input value is process value&#xD;
	Ext_AnalogValue.EXT_Engineering.SignalValue_Visible :=		FALSE;&#xD;
	Wrk_ProcessValue :=																Wrk_Average.Out_Average;&#xD;
END_IF;&#xD;
&#xD;
//State control action&#xD;
 IF TON_InitialCycles.Q THEN&#xD;
	//Input value can be signal value (mA), or direct process value&#xD;
	CASE Wrk_ValueState OF&#xD;
		&#xD;
		0://Use value&#xD;
		Ext_AnalogValue.EXT_Operator.ProcessValue:= Wrk_ProcessValue;&#xD;
		&#xD;
		1://Hold value&#xD;
		Ext_AnalogValue.EXT_Operator.ProcessValue:= Ext_AnalogValue.EXT_Operator.ProcessValue;&#xD;
		&#xD;
		2://Pre defined output&#xD;
		Ext_AnalogValue.EXT_Operator.ProcessValue:= Ext_AnalogValue.EXT_Engineering.StateCfg_PreDefinedValue;&#xD;
		&#xD;
	END_CASE;	&#xD;
 ELSE&#xD;
	 Ext_AnalogValue.EXT_Operator.ProcessValue:= Ext_AnalogValue.EXT_Operator.ProcessValue;&#xD;
 END_IF;&#xD;
&#xD;
Ext_AnalogValue.EXT_Operator.ProcessValue_Percent:=	 ScaleTrans(SclIn:=Ext_AnalogValue.EXT_Operator.ProcessValue, &#xD;
																											X0:=Ext_AnalogValue.EXT_Engineering.ProcessValue_MinLevel, &#xD;
																											Y0:=0, &#xD;
																											X1:=Ext_AnalogValue.EXT_Engineering.ProcessValue_MaxLevel, &#xD;
																											Y1:=100);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	STATISTIC DATA&#xD;
 *************************************************************************)&#xD;
 IF Wrk_ValueState = 2 OR Wrk_AlarmState THEN&#xD;
Ext_AnalogValue.EXT_Statistics.Date_LastFault := DateToString(Wrk_Date_Now);&#xD;
 END_IF;&#xD;
 &#xD;
 IF RE_MidnightPulse.Q THEN&#xD;
	Clear(InOut:=Ext_AnalogValue.EXT_Statistics.MinValue_Today);&#xD;
	Clear(InOut:=Ext_AnalogValue.EXT_Statistics.MaxValue_Today);&#xD;
 END_IF;&#xD;
 &#xD;
 IF Ext_AnalogValue.EXT_Operator.ProcessValue &gt;Ext_AnalogValue.EXT_Statistics.MaxValue_Today THEN&#xD;
	 Ext_AnalogValue.EXT_Statistics.MaxValue_Today:=Ext_AnalogValue.EXT_Operator.ProcessValue;&#xD;
 END_IF;&#xD;
 &#xD;
  IF Ext_AnalogValue.EXT_Operator.ProcessValue &lt;Ext_AnalogValue.EXT_Statistics.MinValue_Today THEN&#xD;
	 Ext_AnalogValue.EXT_Statistics.MinValue_Today:=Ext_AnalogValue.EXT_Operator.ProcessValue;&#xD;
 END_IF;&#xD;
 &#xD;
(*************************************************************************&#xD;
 *	UPDATING STRUCTURE DATA&#xD;
 *************************************************************************)&#xD;
 IF Cfg_ProcessValue_Unit &lt;&gt; '' THEN&#xD;
	 Ext_AnalogValue.EXT_General.Process_Unit :=						Cfg_ProcessValue_Unit;&#xD;
 END_IF;&#xD;
 Ext_AnalogValue.EXT_Engineering.SignalValue_Unit:=				Cfg_SignalValue_Unit;&#xD;
 Ext_AnalogValue.EXT_General.Process_TAG:=							Cfg_ProcessTAG;&#xD;
 Ext_AnalogValue.EXT_General.Connected_ControlCabinet:=		Cfg_ControlCabinet;&#xD;
 Ext_AnalogValue.EXT_General.Controlled_FromController:=		Cfg_ControllerTAG;&#xD;
 Ext_AnalogValue.EXT_Alarm.EXT_Operator.Cfg_Acknowledge:=FALSE;&#xD;
 &#xD;
 (*************************************************************************&#xD;
 *	UPDATING OUTPUT DATA&#xD;
 *************************************************************************)&#xD;
Out_AlarmToken:=Wrk_AlarmToken;</Text></StructuredTextModel>