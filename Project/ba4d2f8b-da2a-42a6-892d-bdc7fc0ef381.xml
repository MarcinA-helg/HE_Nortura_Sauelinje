<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//	NAME:			Interlock                                                                    																																									&#xD;
//	CREATOR:		Helgevold - Ruben Byman                                                                                                                                                                                                                                                        &#xD;
//                                                                                                                                                                                                                                                                                                                            &#xD;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//  VERSION LOG:                                                                                                                                                                                                                                                                                                   &#xD;
//	VERSION		DATE			SIGN						DESCRIPTION                                                                                                                                                                                                                                 &#xD;
//	1.0.0			2025-03-24		Ruben Byman			Initial release&#xD;
//	1.0.1			2025-03-26		Ruben Byman			Bug fix bypass&#xD;
//	1.0.2			2025-03-26		Ruben Byman			Bug fix trigger status&#xD;
//	1.0.3			2025-03-26		Ruben Byman			Bug fix latching&#xD;
//	1.0.4			2025-04-10		Ruben Byman			Moved trigger structure to separate input and reduced max triggers to 8&#xD;
//===============================================================================================================================&#xD;
//&#xD;
//		FUNCTION:&#xD;
//		*	Interlock function based on up to 8 triggers (analog or digital)&#xD;
//		*	Per trigger, write to Triggers.Interlock_Triggers[x].Cfg_Type (#USINT 0, 1, 2 or 3) and .AnalogTrigger or .DigitalTrigger outside of this FB&#xD;
//		*	Cfg_Types: 0 = Not in use, 1 = Digital trigger (TRUE = interlock), 2 = Analog trigger above limit, 3 = Analog trigger below limit&#xD;
//		*	Delay of both activation and reset independently per trigger&#xD;
//		*	Latching optional per trigger, latching requires manual reset&#xD;
//&#xD;
//===============================================================================================================================&#xD;
&#xD;
&#xD;
//Overwrite bypass activated per trigger if not allowed&#xD;
FOR a := 0 TO 7 DO&#xD;
	IF NOT Interlock.EXT_Engineering.TriggerData[a].Cfg_Bypassable THEN&#xD;
		Interlock.EXT_Operator.TriggerData[a].Cfg_Bypass := 0;&#xD;
	END_IF;&#xD;
END_FOR;&#xD;
&#xD;
//Converts Analog and Digital Value to simplified version&#xD;
FOR b := 0 TO 7 DO&#xD;
	HE_AnaExdToAnaSimp(AnalogValue:=Triggers.Interlock_Triggers[b].AnalogTrigger, AnalogValueSimplified=&gt;Interlock.EXT_Engineering.TriggerData[b].Sts_Trig_Analog);&#xD;
	HE_DigExsToDigSimp(DigitalValue:=Triggers.Interlock_Triggers[b].DigitalTrigger, DigitalValueSimplified=&gt;Interlock.EXT_Engineering.TriggerData[b].Sts_Trig_Digital);&#xD;
END_FOR;&#xD;
&#xD;
//Writes data from SCADA&#xD;
FOR c := 0 TO 7 DO&#xD;
	TON_Trig[c].PT := SecToTime(In:=Interlock.EXT_Engineering.TriggerData[c].Cfg_Trig_OnDelay);&#xD;
	TOF_Trig[c].PT := SecToTime(In:=Interlock.EXT_Engineering.TriggerData[c].Cfg_Trig_OffDelay);&#xD;
END_FOR;&#xD;
&#xD;
//Reset of OK latched triggers from SCADA&#xD;
FE_Reset(Clk:=Interlock.EXT_Engineering.Cfg_ResetLatched);&#xD;
&#xD;
//Activates interlock if in use and triggered&#xD;
FOR d := 0 TO 7 DO&#xD;
	//CASE based on type&#xD;
	CASE Triggers.Interlock_Triggers[d].Cfg_Type OF&#xD;
		&#xD;
		0: //Not in use&#xD;
			&#xD;
			Interlock.EXT_Engineering.TriggerData[d].Sts_Trig_Type := 0;&#xD;
			Interlock.EXT_Operator.TriggerData[d].Sts_State := 0;&#xD;
			ResetABit(InOut:=InterlockActive, Pos:=d);&#xD;
			ResetABit(InOut:=BypassActive, Pos:=d);&#xD;
		&#xD;
		1: //Triggered by digital value&#xD;
			&#xD;
			Interlock.EXT_Engineering.TriggerData[d].Sts_Trig_Type := 1;&#xD;
			&#xD;
			//Timers&#xD;
			TON_Trig[d]();&#xD;
			TOF_Trig[d]();&#xD;
			&#xD;
			//Checks if bypassed&#xD;
			IF (Interlock.EXT_Engineering.Cfg_BypassEnable AND Interlock.EXT_Operator.TriggerData[d].Cfg_Bypass) THEN&#xD;
				Interlock.EXT_Operator.TriggerData[d].Sts_State := 1;&#xD;
				ResetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				SetABit(InOut:=BypassActive, Pos:=d);&#xD;
				TON_Trig[d].In := FALSE;&#xD;
				TOF_Trig[d].In := FALSE;&#xD;
				&#xD;
			//If not bypassed, checks if triggered&#xD;
			ELSIF Interlock.EXT_Engineering.TriggerData[d].Sts_Trig_Digital.ProcessValue THEN&#xD;
				TON_Trig[d].In := TRUE;&#xD;
				TOF_Trig[d].In := TRUE;&#xD;
				ResetABit(InOut:=BypassActive, Pos:=d);&#xD;
				//Delayed activation&#xD;
				IF TON_Trig[d].Q THEN&#xD;
					Interlock.EXT_Operator.TriggerData[d].Sts_State := 2;&#xD;
					SetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				END_IF;&#xD;
			ELSE &#xD;
				TON_Trig[d].In := FALSE;&#xD;
				TOF_Trig[d].In := FALSE;&#xD;
				ResetABit(InOut:=BypassActive, Pos:=d);&#xD;
				//If bypass is deactivated and status is OK, go to state 0 immediately&#xD;
				IF Interlock.EXT_Operator.TriggerData[d].Sts_State = 1 THEN&#xD;
					Interlock.EXT_Operator.TriggerData[d].Sts_State := 0;&#xD;
				//Delayed reset of interlock, automatically if not latched, else waits for reset after off delay&#xD;
				ELSIF&#xD;
					NOT TOF_Trig[d].Q AND (NOT Interlock.EXT_Engineering.TriggerData[d].Cfg_Latch OR FE_Reset.Q) THEN&#xD;
						Interlock.EXT_Operator.TriggerData[d].Sts_State := 0;&#xD;
						ResetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				END_IF;&#xD;
			END_IF;&#xD;
			&#xD;
		2: //Triggered by analog value, if above limit&#xD;
			&#xD;
			Interlock.EXT_Engineering.TriggerData[d].Sts_Trig_Type := 2;&#xD;
			&#xD;
			//Timers&#xD;
			TON_Trig[d]();&#xD;
			TOF_Trig[d]();&#xD;
			&#xD;
			//Checks if bypassed&#xD;
			IF (Interlock.EXT_Engineering.Cfg_BypassEnable AND Interlock.EXT_Operator.TriggerData[d].Cfg_Bypass) THEN&#xD;
				Interlock.EXT_Operator.TriggerData[d].Sts_State := 1;&#xD;
				ResetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				SetABit(InOut:=BypassActive, Pos:=d);&#xD;
				TON_Trig[d].In := FALSE;&#xD;
				TOF_Trig[d].In := FALSE;&#xD;
				&#xD;
			//If not bypassed, checks if triggered&#xD;
			ELSIF Interlock.EXT_Engineering.TriggerData[d].Sts_Trig_Analog.ProcessValue &gt; Interlock.EXT_Engineering.TriggerData[d].Cfg_Trig_AnaLimit THEN&#xD;
				TON_Trig[d].In := TRUE;&#xD;
				TOF_Trig[d].In := TRUE;&#xD;
				ResetABit(InOut:=BypassActive, Pos:=d);&#xD;
				//Delayed activation&#xD;
				IF TON_Trig[d].Q THEN&#xD;
					Interlock.EXT_Operator.TriggerData[d].Sts_State := 2;&#xD;
					SetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				END_IF;&#xD;
			ELSE &#xD;
				TON_Trig[d].In := FALSE;&#xD;
				TOF_Trig[d].In := FALSE;&#xD;
				ResetABit(InOut:=BypassActive, Pos:=d);&#xD;
				//If bypass is deactivated and status is OK, go to state 0 immediately&#xD;
				IF Interlock.EXT_Operator.TriggerData[d].Sts_State = 1 THEN&#xD;
					Interlock.EXT_Operator.TriggerData[d].Sts_State := 0;&#xD;
				//Delayed reset of interlock, automatically if not latched, else waits for reset after off delay&#xD;
				ELSIF&#xD;
					NOT TOF_Trig[d].Q AND (NOT Interlock.EXT_Engineering.TriggerData[d].Cfg_Latch OR FE_Reset.Q) THEN&#xD;
						Interlock.EXT_Operator.TriggerData[d].Sts_State := 0;&#xD;
						ResetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				END_IF;&#xD;
			END_IF;&#xD;
		&#xD;
		3: //Triggered by analog value, if below limit&#xD;
			&#xD;
			Interlock.EXT_Engineering.TriggerData[d].Sts_Trig_Type := 3;&#xD;
			&#xD;
			//Timers&#xD;
			TON_Trig[d]();&#xD;
			TOF_Trig[d]();&#xD;
			&#xD;
			//Checks if bypassed&#xD;
			IF (Interlock.EXT_Engineering.Cfg_BypassEnable AND Interlock.EXT_Operator.TriggerData[d].Cfg_Bypass) THEN&#xD;
				Interlock.EXT_Operator.TriggerData[d].Sts_State := 1;&#xD;
				ResetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				SetABit(InOut:=BypassActive, Pos:=d);&#xD;
				TON_Trig[d].In := FALSE;&#xD;
				TOF_Trig[d].In := FALSE;&#xD;
				&#xD;
			//If not bypassed, checks if triggered&#xD;
			ELSIF Interlock.EXT_Engineering.TriggerData[d].Sts_Trig_Analog.ProcessValue &lt; Interlock.EXT_Engineering.TriggerData[d].Cfg_Trig_AnaLimit THEN&#xD;
				TON_Trig[d].In := TRUE;&#xD;
				TOF_Trig[d].In := TRUE;&#xD;
				ResetABit(InOut:=BypassActive, Pos:=d);&#xD;
				//Delayed activation&#xD;
				IF TON_Trig[d].Q THEN&#xD;
					Interlock.EXT_Operator.TriggerData[d].Sts_State := 2;&#xD;
					SetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				END_IF;&#xD;
			ELSE &#xD;
				TON_Trig[d].In := FALSE;&#xD;
				TOF_Trig[d].In := FALSE;&#xD;
				ResetABit(InOut:=BypassActive, Pos:=d);&#xD;
				//If bypass is deactivated and status is OK, go to state 0 immediately&#xD;
				IF Interlock.EXT_Operator.TriggerData[d].Sts_State = 1 THEN&#xD;
					Interlock.EXT_Operator.TriggerData[d].Sts_State := 0;&#xD;
				//Delayed reset of interlock, automatically if not latched, else waits for reset after off delay&#xD;
				ELSIF&#xD;
					NOT TOF_Trig[d].Q AND (NOT Interlock.EXT_Engineering.TriggerData[d].Cfg_Latch OR FE_Reset.Q) THEN&#xD;
						Interlock.EXT_Operator.TriggerData[d].Sts_State := 0;&#xD;
						ResetABit(InOut:=InterlockActive, Pos:=d);&#xD;
				END_IF;&#xD;
			END_IF;&#xD;
	&#xD;
	END_CASE;&#xD;
END_FOR;&#xD;
&#xD;
&#xD;
//Writes overall status to SCADA and output pins&#xD;
//Interlock status, TRUE if 1 or more triggers are interlocking&#xD;
IF InterlockActive &gt; 0 THEN&#xD;
	Interlock.EXT_Operator.Sts_Interlocked := TRUE;&#xD;
	Sts_Interlock := TRUE;&#xD;
ELSE&#xD;
	Interlock.EXT_Operator.Sts_Interlocked := FALSE;&#xD;
	Sts_Interlock := FALSE;&#xD;
	FirstInterlock := 0;&#xD;
END_IF;&#xD;
&#xD;
//Bypass status, TRUE if 1 or more triggers are bypassed AND overall bypass is enabled&#xD;
IF BypassActive &gt; 0 THEN&#xD;
	Interlock.EXT_Operator.Sts_Bypassed := TRUE;&#xD;
	Sts_Bypassed := TRUE;&#xD;
ELSE&#xD;
	Interlock.EXT_Operator.Sts_Bypassed := FALSE;&#xD;
	Sts_Bypassed := FALSE;&#xD;
END_IF;&#xD;
&#xD;
//Stores NOT OK triggers at time of NOT OK&#xD;
RE_Interlock(Clk:=Sts_Interlock);&#xD;
IF RE_Interlock.Q THEN&#xD;
	FirstInterlock := InterlockActive;&#xD;
END_IF;&#xD;
&#xD;
//Writes first active triggers to SCADA&#xD;
FOR e := 0 TO 7 DO&#xD;
	Interlock.EXT_Operator.TriggerData[e].Sts_FirstActive := TestABit(In:=FirstInterlock, Pos:=e);&#xD;
END_FOR;</Text></StructuredTextModel>