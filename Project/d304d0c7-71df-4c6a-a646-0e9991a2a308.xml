<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//	NAME:			 HE_AlarmAnalog                                                                                                                                                                                                                                                                 &#xD;
//	CREATOR:		 William Veim, Helgevold Elektro                                                                                                                                                                                                                                             &#xD;
//                                                                                                                                                                                                                                                                                                                            &#xD;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//  VERSION LOG:                                                                                                                                                                                                                                                                                                   &#xD;
//	VERSION			DATE				SIGN						DESCRIPTION                                                                                                                                                                                                                                 &#xD;
//	1.0.0					31.03.2025		William Veim			Initial Release&#xD;
//	1.0.1					16.05.2025		Ruben Byman			Added return to state 0 (no alarm) and corrected crocodile bugs&#xD;
// 1.0.2					24.06.2025		Fredrik Bjerkenes		Made input for string from HE ana logic and copy to int_alarm_processvalue&#xD;
//===============================================================================================================================&#xD;
//&#xD;
//		DESCRIPTION:&#xD;
//&#xD;
//&#xD;
//==============================================================================================================================&#xD;
&#xD;
(*************************************************************************&#xD;
 *	INIT VARAIBELS&#xD;
 *************************************************************************)&#xD;
 &#xD;
 	//Running function and sets delay time&#xD;
 	TON_L_Alarm(PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_Delay));&#xD;
	TON_H_Alarm(PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_Delay));&#xD;
	TON_HH_Alarm(PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_FullAlarm_Delay));&#xD;
	TON_LL_Alarm(PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_FullAlarm_Delay));&#xD;
&#xD;
	//Running function&#xD;
	TON_L_AlarmReturn();&#xD;
	TON_H_AlarmReturn();&#xD;
	TON_HH_AlarmReturn();&#xD;
	TON_LL_AlarmReturn();&#xD;
	&#xD;
	//Sets delay&#xD;
	IF Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_UseReturnDelay THEN&#xD;
		TON_L_AlarmReturn.PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_Delay);&#xD;
	ELSE&#xD;
		TON_L_AlarmReturn.PT:=TIME#0ms;&#xD;
	END_IF;&#xD;
	&#xD;
	//Sets delay&#xD;
	IF Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_UseReturnDelay THEN&#xD;
		TON_H_AlarmReturn.PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_Delay);&#xD;
	ELSE&#xD;
		TON_H_AlarmReturn.PT:=TIME#0ms;&#xD;
	END_IF;&#xD;
&#xD;
	//Sets delay&#xD;
	IF Ext_AlarmAnalog.EXT_Engineering.Cfg_FullAlarm_UseReturnDelay THEN&#xD;
		TON_LL_AlarmReturn.PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_Delay);&#xD;
	ELSE&#xD;
		TON_LL_AlarmReturn.PT:=TIME#0ms;&#xD;
	END_IF;&#xD;
	&#xD;
	//Sets delay&#xD;
	IF Ext_AlarmAnalog.EXT_Engineering.Cfg_FullAlarm_UseReturnDelay THEN&#xD;
		TON_HH_AlarmReturn.PT:=SecToTime(Ext_AlarmAnalog.EXT_Engineering.Cfg_PreAlarm_Delay);&#xD;
	ELSE&#xD;
		TON_HH_AlarmReturn.PT:=TIME#0ms;&#xD;
	END_IF;&#xD;
	&#xD;
(*************************************************************************&#xD;
 *	ALARM TIMER&#xD;
 *************************************************************************)&#xD;
 Wrk_DigitalAlarm:= Ext_AlarmGeneral.EXT_General.Sts_Alarm_Status = 1 AND NOT Wrk_AlarmH AND NOT Wrk_AlarmHH AND NOT Wrk_AlarmL AND NOT Wrk_AlarmLL; //Digital alarm if alarm status and not any analog alarms&#xD;
 &#xD;
 Wrk_GeneralTrigger:= Ext_AlarmGeneral.EXT_Operator.Cfg_OnOff AND NOT Ext_AlarmGeneral.EXT_Engineering.Sts_Suppressed AND (Inp_Quality &lt; 2 AND NOT Wrk_DigitalAlarm);&#xD;
 &#xD;
&#xD;
IF Wrk_GeneralTrigger THEN&#xD;
	&#xD;
	//ALARM CONTROL LOW ALARM&#xD;
	//-----------------------------------&#xD;
	//Alarm trigger&#xD;
	IF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_L AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_L &gt; Inp_Process_Value THEN&#xD;
		TON_L_Alarm.In:=TRUE;&#xD;
		TON_L_AlarmReturn.In:=FALSE;&#xD;
		IF TON_L_Alarm.Q THEN&#xD;
			Wrk_AlarmL:=TRUE;&#xD;
			Wrk_Suffix:= 'Low limit';&#xD;
		END_IF;&#xD;
		&#xD;
	//Alarm return without latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_L AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_L &lt; Inp_Process_Value AND NOT Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch THEN&#xD;
		TON_L_AlarmReturn.In:=TRUE;&#xD;
		TON_L_Alarm.In:=FALSE;&#xD;
		IF TON_L_AlarmReturn.Q THEN&#xD;
			Wrk_AlarmL:=FALSE;&#xD;
		END_IF;&#xD;
		&#xD;
	//Alarm return with latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_L AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_L &lt; Inp_Process_Value AND Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch  THEN&#xD;
		TON_L_AlarmReturn.In:=TRUE;&#xD;
		TON_L_Alarm.In:=FALSE;&#xD;
		IF TON_L_AlarmReturn.Q AND Ext_AlarmGeneral.EXT_Operator.Cfg_Acknowledge THEN&#xD;
			Wrk_AlarmL:=FALSE;&#xD;
		END_IF;	&#xD;
		&#xD;
	//Alarm return (turned off, no delay)&#xD;
	ELSIF NOT Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_L THEN&#xD;
		Wrk_AlarmL:=FALSE;&#xD;
		TON_L_Alarm.In:=FALSE;&#xD;
	END_IF;&#xD;
	&#xD;
	//ALARM CONTROL HIGH ALARM&#xD;
	//-----------------------------------&#xD;
	//Alarm trigger&#xD;
	IF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_H AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_H &lt; Inp_Process_Value THEN&#xD;
		TON_H_Alarm.In:=TRUE;&#xD;
		TON_H_AlarmReturn.In:=FALSE;&#xD;
		IF TON_H_Alarm.Q THEN&#xD;
			Wrk_AlarmH:=TRUE;&#xD;
			Wrk_Suffix:= 'High limit';&#xD;
		END_IF;&#xD;
	//Alarm return without latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_H AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_H &gt; Inp_Process_Value AND NOT Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch  THEN&#xD;
		TON_H_AlarmReturn.In:=TRUE;&#xD;
		TON_H_Alarm.In:=FALSE;&#xD;
		IF TON_H_AlarmReturn.Q THEN&#xD;
			Wrk_AlarmH:=FALSE;&#xD;
		END_IF;&#xD;
	//Alarm return with latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_H AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_H &gt; Inp_Process_Value AND Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch  THEN&#xD;
		TON_H_AlarmReturn.In:=TRUE;&#xD;
		TON_H_Alarm.In:=FALSE;&#xD;
		IF TON_H_AlarmReturn.Q AND Ext_AlarmGeneral.EXT_Operator.Cfg_Acknowledge THEN&#xD;
			Wrk_AlarmH:=FALSE;&#xD;
		END_IF;	&#xD;
	//Alarm return (turned off, no delay)&#xD;
	ELSIF NOT Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_H THEN&#xD;
		Wrk_AlarmH:=FALSE;&#xD;
		TON_H_Alarm.In:=FALSE;&#xD;
	END_IF;&#xD;
	&#xD;
	//ALARM CONTROL LOW-LOW ALARM&#xD;
	//-----------------------------------&#xD;
	//Alarm trigger&#xD;
	IF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_LL AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_LL &gt; Inp_Process_Value THEN&#xD;
		TON_LL_Alarm.In:=TRUE;&#xD;
		TON_LL_AlarmReturn.In:=FALSE;&#xD;
		IF TON_LL_Alarm.Q THEN&#xD;
			Wrk_AlarmLL:=TRUE;&#xD;
			Wrk_Suffix:= 'Critical low limit';&#xD;
		END_IF;&#xD;
	//Alarm return without latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_LL AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_LL &lt; Inp_Process_Value AND NOT Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch  THEN&#xD;
		TON_LL_AlarmReturn.In:=TRUE;&#xD;
		TON_LL_Alarm.In:=FALSE;&#xD;
		IF TON_LL_AlarmReturn.Q THEN&#xD;
			Wrk_AlarmLL:=FALSE;&#xD;
		END_IF;&#xD;
	//Alarm return with latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_LL AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_LL &lt; Inp_Process_Value AND Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch  THEN&#xD;
		TON_LL_AlarmReturn.In:=TRUE;&#xD;
		TON_LL_Alarm.In:=FALSE;&#xD;
		IF TON_LL_AlarmReturn.Q AND Ext_AlarmGeneral.EXT_Operator.Cfg_Acknowledge THEN&#xD;
			Wrk_AlarmLL:=FALSE;&#xD;
		END_IF;	&#xD;
	//Alarm return (turned off, no delay)&#xD;
	ELSIF NOT Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_LL THEN&#xD;
		Wrk_AlarmLL:=FALSE;&#xD;
		TON_LL_Alarm.In:=FALSE;&#xD;
	END_IF;&#xD;
	&#xD;
&#xD;
	//ALARM CONTROL HIGH-HIGH ALARM&#xD;
	//------------------------------------------&#xD;
	//Alarm trigger&#xD;
	IF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_HH AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_HH &lt; Inp_Process_Value THEN&#xD;
		TON_HH_Alarm.In:=TRUE;&#xD;
		TON_HH_AlarmReturn.In:=FALSE;&#xD;
		IF TON_HH_Alarm.Q THEN&#xD;
			Wrk_AlarmHH:=TRUE;&#xD;
			Wrk_Suffix:= 'Cirtical high limit';&#xD;
		END_IF;&#xD;
	//Alarm return without latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_HH AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_HH &gt; Inp_Process_Value AND NOT Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch  THEN&#xD;
		TON_HH_AlarmReturn.In:=TRUE;&#xD;
		TON_HH_Alarm.In:=FALSE;&#xD;
		IF TON_HH_AlarmReturn.Q THEN&#xD;
			Wrk_AlarmHH:=FALSE;&#xD;
		END_IF;&#xD;
	//Alarm return with latch&#xD;
	ELSIF Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_HH AND Ext_AlarmAnalog.EXT_Operator.Cfg_Limit_HH &gt; Inp_Process_Value AND Ext_AlarmGeneral.EXT_Engineering.Cfg_Latch  THEN&#xD;
		TON_HH_AlarmReturn.In:=TRUE;&#xD;
		TON_HH_Alarm.In:=FALSE;&#xD;
		IF TON_HH_AlarmReturn.Q AND Ext_AlarmGeneral.EXT_Operator.Cfg_Acknowledge THEN&#xD;
			Wrk_AlarmHH:=FALSE;&#xD;
		END_IF;	&#xD;
	//Alarm return (turned off, no delay)&#xD;
	ELSIF NOT Ext_AlarmAnalog.EXT_Operator.Cfg_OnOff_HH THEN&#xD;
		Wrk_AlarmHH:=FALSE;&#xD;
		TON_HH_Alarm.In:=FALSE;&#xD;
	END_IF;&#xD;
	&#xD;
	//General trigger not active&#xD;
ELSE&#xD;
	Wrk_AlarmL:=FALSE;&#xD;
	Wrk_AlarmH:=FALSE;&#xD;
	Wrk_AlarmLL:=FALSE;&#xD;
	Wrk_AlarmHH:=FALSE;&#xD;
	TON_L_Alarm.In:=FALSE;&#xD;
	TON_H_Alarm.In:=FALSE;&#xD;
	TON_LL_Alarm.In:=FALSE;&#xD;
	TON_HH_Alarm.In:=FALSE;&#xD;
END_IF;&#xD;
 &#xD;
 (*************************************************************************&#xD;
 *	UPDATE STRUCTURE&#xD;
 *************************************************************************)&#xD;
 &#xD;
 //Trigger SMS sending (SMS sending only if activated)&#xD;
 IF Wrk_AlarmL AND Ext_AlarmAnalog.EXT_Engineering.SMS_Pre AND NOT Wrk_AlarmL_Sendt THEN&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_State:=1;&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_TimeToNextPri:=TIME#0ms;&#xD;
	Wrk_AlarmL_Sendt:=TRUE;&#xD;
ELSIF NOT Wrk_AlarmL THEN&#xD;
	Wrk_AlarmL_Sendt:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF Wrk_AlarmH AND Ext_AlarmAnalog.EXT_Engineering.SMS_Pre AND NOT Wrk_AlarmH_Sendt THEN&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_State:=1;&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_TimeToNextPri:=TIME#0ms;&#xD;
	Wrk_AlarmH_Sendt:=TRUE;&#xD;
ELSIF NOT Wrk_AlarmH THEN&#xD;
	Wrk_AlarmH_Sendt:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF Wrk_AlarmLL AND Ext_AlarmAnalog.EXT_Engineering.SMS_Full AND NOT Wrk_AlarmLL_Sendt THEN&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_State:=1;&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_TimeToNextPri:=TIME#0ms;&#xD;
	Wrk_AlarmLL_Sendt:=TRUE;&#xD;
ELSIF NOT Wrk_AlarmLL THEN&#xD;
	Wrk_AlarmLL_Sendt:=FALSE;&#xD;
END_IF;&#xD;
&#xD;
IF Wrk_AlarmHH AND Ext_AlarmAnalog.EXT_Engineering.SMS_Full AND NOT Wrk_AlarmHH_Sendt THEN&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_State:=1;&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_TimeToNextPri:=TIME#0ms;&#xD;
	Wrk_AlarmHH_Sendt:=TRUE;&#xD;
ELSIF NOT Wrk_AlarmHH THEN&#xD;
	Wrk_AlarmHH_Sendt:=FALSE;&#xD;
END_IF;&#xD;
 &#xD;
//DATA TO SCADA&#xD;
Ext_AlarmAnalog.EXT_Operator.Sts_Alarm_L:=Wrk_AlarmL;&#xD;
Ext_AlarmAnalog.EXT_Operator.Sts_Alarm_H:=Wrk_AlarmH;&#xD;
Ext_AlarmAnalog.EXT_Operator.Sts_Alarm_LL:=Wrk_AlarmLL;&#xD;
Ext_AlarmAnalog.EXT_Operator.Sts_Alarm_HH:=Wrk_AlarmHH;&#xD;
&#xD;
&#xD;
IF NOT Wrk_AlarmL AND NOT Wrk_AlarmH AND NOT Wrk_AlarmLL AND NOT Wrk_AlarmHH AND NOT Wrk_DigitalAlarm THEN&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_State := 0;&#xD;
	&#xD;
ELSIF Wrk_AlarmL OR Wrk_AlarmH OR Wrk_AlarmLL OR Wrk_AlarmHH AND NOT Wrk_DigitalAlarm THEN&#xD;
	&#xD;
	//Updating structure to internal alarm&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_Process_Suffix:=Wrk_Suffix;&#xD;
	Int_Alarm[Inp_AlarmToken].Sts_Process_Value := Inp_Process_Value_String;&#xD;
	&#xD;
	//Updating structure to SCADA&#xD;
	Ext_AlarmGeneral.EXT_General.Sts_Alarm_Message:=Wrk_Suffix; &#xD;
	Ext_AlarmGeneral.EXT_General.Sts_Alarm_Status:=1; //Alarm triggerd&#xD;
END_IF;</Text></StructuredTextModel>