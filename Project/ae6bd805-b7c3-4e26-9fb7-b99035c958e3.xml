<StructuredTextModel xmlns="http://schemas.datacontract.org/2004/07/Omron.Cxap.Modules.StructuredText.Core" xmlns:i="http://www.w3.org/2001/XMLSchema-instance"><Text>//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//	NAME: 		HE_VFD_WEG_CFW900_Wrapper                                                                                                                                                                                                                                                                    &#xD;
//	CREATOR:	    Jan Magne Dybvik, Helgevold Elektro                                                                                                                                                                                                                                            &#xD;
//                                                                                                                                                                                                                                                                                                                            &#xD;
//------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ &#xD;
//  VERSION LOG:                                                                                                                                                                                                                                                                                                   &#xD;
//	VERSION			DATE				SIGN						DESCRIPTION                                                                                                                                                                                                                                 &#xD;
// 1.0.0				31.01.2025			JMD							Initial Release&#xD;
//	1.0.1				09.04.2025			JMD							Removed duplicate assignments, added Output Parameters for mesured values.&#xD;
//	1.0.2				15.04.2025			Ruben Byman			Added LOTO and bugfix statistics&#xD;
//	1.0.3				26.06.2025			JMD							Overwrite state and fault strings if communication error with drive&#xD;
//&#xD;
//===============================================================================================================================&#xD;
//&#xD;
//		DESCRIPTION:&#xD;
//		Interface between HE_FrekvOmf_Logic and WEG CFW900 VFD&#xD;
//&#xD;
//		FUNCTION:&#xD;
//		Translates Ethernet/IP input and output asseblies forCFW900 to HE_FrekvOmf_Logic Parameters&#xD;
//&#xD;
//===============================================================================================================================&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	IMPORTANT!&#xD;
 * Do NOT use WEG EDS file&#xD;
 * Use Omron Generic EDS EIP&#xD;
 * Input Assembly: 150&#xD;
 * Input Size (Bytes): 42&#xD;
 * Output Assembly: 100&#xD;
 * Output Size (Bytes): 4&#xD;
 *&#xD;
 *************************************************************************)&#xD;
 &#xD;
// Reading Word Quantity: 19&#xD;
// Reading Data Word #01: 690		WEG Status Word 2&#xD;
// Reading Data Word #02: 7016	Digital Inputs&#xD;
// Reading Data Word #03: 3			Inverter Current&#xD;
// Reading Data Word #04: 7			Inverter Voltage&#xD;
// Reading Data Word #05: 10		InverterPower&#xD;
// Reading Data Word #06: 11		Inverter CosPhi&#xD;
// Reading Data Word #07: 4			DC Link Voltage&#xD;
// Reading Data Word #08: 48		Inverter kWh&#xD;
// Reading Data Word #09: 3046	Inverter MWh&#xD;
// Reading Data Word #10: 3045	Inverter GWh&#xD;
// Reading Data Word #11: 42		Time Powered&#xD;
// Reading Data Word #12: 6			InverterStatus&#xD;
// Reading Data Word #13: 4100	Last Fault&#xD;
// Reading Data Word #14: 4150	Last Alarm&#xD;
// Reading Data Word #15: 2020	Phase U/T1 IGBT1 Temperature&#xD;
// Reading Data Word #16: 2021	Phase V/T2 IGBT2 Temperature&#xD;
// Reading Data Word #17: 2022	Phase W/T3 IGBT3 Temperature&#xD;
// Reading Data Word #18: 2029	Internal Air Temperature, Power&#xD;
// Reading Data Word #19: 990		Internal Air Temperature, Control&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	Update Inputs&#xD;
 *************************************************************************)&#xD;
 &#xD;
 // Communication failure&#xD;
 Wrk_ComFault:= Inp_EIP_Interface[Cfg_DriveIP];&#xD;
 &#xD;
// Input Parmeter&#xD;
Wrk_VFD_Logic.Cfg_AutoInUse:=			Cfg_AutoAvailable;&#xD;
Wrk_VFD_Logic.Inp_AutoRunFwd:=		Inp_AutoStartRef;&#xD;
Wrk_VFD_Logic.Inp_AutoSpeedRef:=		Inp_AutoSpeedRef;&#xD;
Wrk_VFD_Logic.Inp_Interlock := 				Inp_Interlock;&#xD;
Wrk_VFD_Logic.Cfg_Interlock_InUse:=	Cfg_Interlock_InUse;&#xD;
Wrk_VFD_Logic.Cfg_STO_InUse:=			Cfg_STO_InUse;&#xD;
Wrk_VFD_Logic.Inp_ComFault := 			Wrk_ComFault;&#xD;
Wrk_VFD_Logic.Inp_AlmSuppress:=			Inp_AlmSuppress;&#xD;
Wrk_VFD_Logic.Inp_AlmSuppressDesc:= 	Inp_AlmSuppressDesc;&#xD;
Wrk_VFD_Logic.Cfg_AlmSuppress_IfOff:=	Cfg_AlmSuppress_IfOff;&#xD;
Wrk_VFD_Logic.Cfg_LOTO_InUse :=		Cfg_LOTO_InUse;&#xD;
Wrk_VFD_Logic.Inp_LOTO :=					Inp_LOTO;&#xD;
&#xD;
// Fieldbus Input&#xD;
Wrk_VFD_Logic.Inp_STO						:= Ext_VFD_Input.StatusWord1.Bit[0]; // SW1 Bit 0: STO&#xD;
Wrk_VFD_Logic.Inp_Online					:= Ext_VFD_Input.StatusWord2.Bit[2]; // SW2 Bit 2: Pre-Charge OK&#xD;
Wrk_VFD_Logic.Inp_Ready					:=	Ext_VFD_Input.StatusWord1.Bit[9] AND NOT Ext_VFD_Input.StatusWord1.Bit[6] ; // SW1  Bit 9: Enabled, SW1  Bit 6: Config. Mode, &#xD;
Wrk_VFD_Logic.Inp_VoltageEnabled 	:=	Ext_VFD_Input.StatusWord1.Bit[9];  // SW1 Bit 9: Enabled&#xD;
Wrk_VFD_Logic.Inp_RunningFwd 		:= Ext_VFD_Input.StatusWord1.Bit[8] AND NOT Ext_VFD_Input.StatusWord1.Bit[10] ;  // SW1  Bit 8: Running, SW1 Bit 10: Reverse &#xD;
Wrk_VFD_Logic.Inp_Error  					:= Ext_VFD_Input.StatusWord1.Bit[15]; // SW1 Bit 15: Fault &#xD;
Wrk_VFD_Logic.Inp_Warning 				:=	Ext_VFD_Input.StatusWord1.Bit[7]; // SW1 Bit 17: Alarm&#xD;
Wrk_VFD_Logic.Inp_Remote 				:= NOT Ext_VFD_Input.StatusWord1.Bit[2]; // SW1 Bit 2: Local&#xD;
Wrk_VFD_Logic.Inp_LocalStop 			:= FALSE;&#xD;
&#xD;
Wrk_VFD_Logic.Inp_ActSpeed := ScaleTrans(&#xD;
											   		SclIn:=INT_TO_REAL(WORD_TO_INT(Ext_VFD_Input.ActualSpeed.Wrd)),&#xD;
												  	X0:=REAL#0.0,&#xD;
												  	Y0:=REAL#0.0,&#xD;
												  	X1:=REAL#10000.0,&#xD;
												  	Y1:=REAL#100.0,&#xD;
													SclOfs := REAL#0.0);&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	VFD Power, Current, Energy&#xD;
 *************************************************************************)&#xD;
 &#xD;
	Wrk_VFD_Logic.Inp_Power :=  INT_TO_REAL(WORD_TO_INT(Ext_VFD_Input.Power.Wrd)) * 0.01; // kW&#xD;
	Wrk_VFD_Logic.Inp_Current := INT_TO_REAL(WORD_TO_INT(Ext_VFD_Input.Current.Wrd)) * 0.1;&#xD;
	Wrk_Energy := INT_TO_REAL(WORD_TO_INT(Ext_VFD_Input.kWh.Wrd)) * 1e-1; // kWh&#xD;
	Wrk_Energy := Wrk_Energy + INT_TO_REAL(WORD_TO_INT(Ext_VFD_Input.MWh.Wrd)) * 1e3; // MWh&#xD;
	Wrk_Energy := Wrk_Energy + INT_TO_REAL(WORD_TO_INT(Ext_VFD_Input.GWh.Wrd)) * 1e6; // GWh&#xD;
	Wrk_VFD_Logic.Inp_Energy := Wrk_Energy;&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	Runtime Statistics&#xD;
 *************************************************************************)&#xD;
 &#xD;
	IF Wrk_VFD_Logic.Sts_RunningFwd THEN&#xD;
			Wrk_Runtime := ADD_TIME(Wrk_Runtime, GetMyTaskInterval()); &#xD;
	END_IF;&#xD;
	&#xD;
	Wrk_VFD_Logic.Inp_VFD_TotalRunTime := LINT_TO_UDINT( TimeToSec(Wrk_Runtime) / 3600);&#xD;
	Wrk_VFD_Logic.Inp_VFD_TotalOnTime := WORD_TO_ULINT(Ext_VFD_Input.PowerOnTime.Wrd);&#xD;
	&#xD;
(*************************************************************************&#xD;
 *	Execute VFD Logic&#xD;
 *************************************************************************)&#xD;
 &#xD;
Wrk_VFD_Logic(Ext_VFD:=Ext_VFD, &#xD;
							Int_Alarm:=Int_Alarm);&#xD;
&#xD;
(*************************************************************************&#xD;
 *	Automatic reset of Fault F021 - DC Link Undervoltage&#xD;
 *************************************************************************)&#xD;
&#xD;
IF  Cfg_AutoResetDCL_UV AND  NOT Wrk_ComFault AND Wrk_VFD_Logic.Inp_Error AND Ext_VFD_Input.LastFault.Wrd = 21 THEN&#xD;
	Wrk_ResetPulseTON(In := NOT Wrk_ResetPulseTON.Q, PT := T#500ms);&#xD;
	IF Wrk_ResetPulseTON.Q THEN&#xD;
		Wrk_AutoReset := NOT Wrk_AutoReset;&#xD;
	END_IF;&#xD;
ELSE&#xD;
	Wrk_AutoReset := FALSE;&#xD;
END_IF;&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	Update SCADA&#xD;
 *************************************************************************)&#xD;
&#xD;
// Frekvensomformer Status&#xD;
IF Wrk_ComFault THEN&#xD;
	Ext_VFD.EXT_Operator.Actual_State := 'Unkown State';&#xD;
	Ext_VFD.EXT_Operator.Active_Error := 'Communication Error';&#xD;
ELSE&#xD;
	Ext_VFD.EXT_Operator.Actual_State := HE_WEG_Drive_State(Inp_InverterStatus := Ext_VFD_Input.InverterStatus.Wrd);	&#xD;
	Ext_VFD.EXT_Operator.Active_Error:=HE_WEG_Drive_Fault(Inp_InverterFault := Ext_VFD_Input.LastFault.Wrd);&#xD;
END_IF;&#xD;
&#xD;
&#xD;
&#xD;
(*************************************************************************&#xD;
 *	Update Outputs&#xD;
 *************************************************************************)&#xD;
 &#xD;
// Output Parameters&#xD;
Sts_AvailableAuto := Wrk_VFD_Logic.Sts_AvailableAuto;&#xD;
Sts_Interlock := Wrk_VFD_Logic.Sts_Interlock;&#xD;
Sts_RunningFwd := Wrk_VFD_Logic.Sts_RunningFwd;&#xD;
Val_DCLink_Voltage := WORD_TO_UINT(Ext_VFD_Input.DCVoltage.Wrd);&#xD;
Val_IGBT1_Temp := UINT_TO_REAL(WORD_TO_UINT(Ext_VFD_Input.TemperatureIGBT1.Wrd)) / 10.0;&#xD;
Val_IGBT2_Temp := UINT_TO_REAL(WORD_TO_UINT(Ext_VFD_Input.TemperatureIGBT2.Wrd)) / 10.0;&#xD;
Val_IGBT3_Temp := UINT_TO_REAL(WORD_TO_UINT(Ext_VFD_Input.TemperatureIGBT3.Wrd)) / 10.0;&#xD;
Val_PowerTemp := UINT_TO_REAL(WORD_TO_UINT(Ext_VFD_Input.TemperaturePower.Wrd)) / 10.0;&#xD;
Val_ControlTemp := UINT_TO_REAL(WORD_TO_UINT(Ext_VFD_Input.TemperatureControl.Wrd)) / 10.0;&#xD;
Val_MotorlTemp := UINT_TO_REAL(WORD_TO_UINT(Ext_VFD_Input.TemperatureMotor.Wrd)) / 10.0;&#xD;
&#xD;
// Fieldbus Output&#xD;
Ext_VFD_Output.ControlWord.Wrd := 16#0;&#xD;
Ext_VFD_Output.ControlWord.Bit[0] :=Wrk_VFD_Logic.Out_RunFwd; // Run FWD Command&#xD;
Ext_VFD_Output.ControlWord.Bit[1] := NOT Inp_Interlock; // Enable VFD&#xD;
Ext_VFD_Output.ControlWord.Bit[5] := TRUE; // Net Ctrl&#xD;
Ext_VFD_Output.ControlWord.Bit[6] := TRUE; // Net Ref&#xD;
Ext_VFD_Output.ControlWord.Bit[7]:= Wrk_VFD_Logic.Out_FaultReset OR Wrk_AutoReset; // Fault Reset&#xD;
&#xD;
Ext_VFD_Output.SpeedReference.Wrd:= INT_TO_WORD(REAL_TO_INT(ScaleTrans(&#xD;
																SclIn:=Wrk_VFD_Logic.Val_SpeedRef,&#xD;
																X0:=0.0,&#xD;
																Y0:=0.0,&#xD;
																X1:=100.0,&#xD;
																Y1:=10000.0)));</Text></StructuredTextModel>